{|
  | '''Warning'''
  * This is a '''readonly''' and '''text-based''' archive of a deprecated wiki.
  * '''Images''' and '''attachments''' have been removed to conserve space.
  * '''Links''' may not work and there may be formatting issues.
  * A '''compressed''' version with images and the original syntax is in the repo '''Releases'''.
|}

__TOC__

== Concise Listing of Git use cases ==

* The Commit
<pre> 
git show c82aa23
</pre> 

* The tip of the foobranch branch
<pre>
git show foobranch 
</pre>

* The tip of current branch
<pre>
git show HEAD
</pre>

* The parent of head, previous state of the project
<pre>
git show HEAD^ 
</pre>

* Same as HEAD^
<pre>
git show HEAD~1
</pre>

* Grandparent
<pre>
git show HEAD^^
</pre>

* Same as HEAD^^
<pre>
git show HEAD~2
</pre>

* To see whether a particular commit is in a particular branch
<pre>
git log --pretty=one <branch> | grep sha1
</pre>

=== Sets of commits ===

git log v2.5..v2.6            # commits between v2.5 and v2.6

git log v2.5..                # commits since v2.5

git log --since="2 weeks ago" # commits from the last 2 weeks

git log v2.5.. Makefile       # commits since v2.5 which modify Makefile

---------------------------------------------------------------

=== Commits where one is not an ancestor of the other ===

If the tips of the branches "stable-release" and "master"
diverged from a common commit some time ago, then

git log stable..experimental

will list commits made in the experimental branch but not in the stable branch, while

git log experimental..stable

will show the list of commits made on the stable branch but not the experimental branch.

---------------------------------------------------------------

=== Merging, etc ===

git pull /home/bob/myrepo master # merge changes from bob's master branch onto my current branch

(pull fetches and merges)

git fetch /home/bob/myrepo master

git log -p HEAD..FETCH_HEAD

(two dot form - 'everything reachable from FETCH_HEAD, excluding anything reachable from HEAD')
or

gitk HEAD...FETCH_HEAD

(three dot form - 'show everything reachable from either, exclude anything reachable from both)
(fetch and look at everything between HEAD and head of what bob had)

-----------------------------------------------------------------

=== Using remote repositories ===

git remote add bob /home/bob/myrepo

git fetch bob

git log -p master..bob/master # list of changes since bob branched from my master

git merge bob/master # merge changes in bob into my master branch

git pull . remotes/bob/master # same as the last one # git pull always merges into the current branch

git push --tags remotename localbranch:remotebranch # creates remote branch

git push remotename :remotebranch # deletes the remote branch

-----------------------------------------------------------------

=== rebasing ===

git rebase master topic # place all new commits in topic on top of master

----------------------------------------------------------------

=== Deleting a tag from the main repo ===

Delete the unwanted tag locally then:

git push origin :BadTag

----------------------------------------------------------------

=== Assorted ===

gitk --since="2 weeks ago" drivers/

git diff v2.5:Makefile HEAD:Makefile.in # diff different files in different commits

git reset --hard HEAD - throw away all changes

git reset --hard HEAD^ - throw away the last commit that was made

git grep "foo" existingtagname

git diff tagname HEAD

git branch newbranchname existingtagname

------------------------------------------------------------------

Accessing remote branch lpia

git clone --reference /home/sconklin/src/reference-trees/linus git://kernel.ubuntu.com/ubuntu/ubuntu-hardy.git hardy-kernel

git checkout origin/lpia

------------------------------------------------------------------

Rebase against a tree that may not have a common ancestry, such as linux-next, while preserving local commits.

Assuming your local changes are at the top of the tree:

git rebase --onto next/master HEAD~N

where N is the number of local commits you wish to preserve.

It would be common to do something like placing a tag at the tip so you can use that for the next rebase:

git rebase --onto next/master ubuntu-next-base

git tag -f ubuntu-next-base next/master
