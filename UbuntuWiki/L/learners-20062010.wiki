{|
| '''Warning'''
* This is a '''readonly''' and '''text-based''' archive of a deprecated wiki.
* '''Images''' and '''attachments''' have been removed to conserve space.
* '''Links''' may not work.
* A '''full compressed version''' of the wiki is available on archive.org
|}

__TOC__

<pre>

<pedro3005>	[Jun 20 17:07:22] bgs100, I did my homework
<pedro3005>	[Jun 20 17:07:28] with all the bonuses
<bgs100>	[Jun 20 17:07:36] Cool
<bgs100>	[Jun 20 17:07:40] Show me it in 2 hours :p
<pedro3005>	[Jun 20 17:07:48] bgs100, 25 lines acceptable?
<bgs100>	[Jun 20 17:09:26] Sure
<bgs100>	[Jun 20 19:10:06] bb in a few
<pedro3005>	[Jun 20 19:10:27] bgs100, class today?
<bgs100>	[Jun 20 19:11:19] yes, but g2g for a few minutes
<pedro3005>	[Jun 20 19:12:01] ok
<pedro3005>	[Jun 20 20:30:24] bgs100, there?
<seidos>	[Jun 20 20:38:05] bgs100, are you there?
<seidos>	[Jun 20 20:40:44] Snova are you there?
<Snova>	[Jun 20 20:46:52] seidos: yes.
<seidos>	[Jun 20 20:48:11] Snova, can you explain something to me?
<seidos>	[Jun 20 20:48:21] I tried doing one of euler's problems with c
<seidos>	[Jun 20 20:48:29] and I tried using a while loop to solve the problem
<seidos>	[Jun 20 20:48:35] but the answer is off by 1000
<seidos>	[Jun 20 20:49:01] pedro3005, solved it with a for loop, while I used a while loop.  can you tell me if a while loop can possibly solve the problem?
<seidos>	[Jun 20 20:50:19] Snova, that's about it
<Snova>	[Jun 20 20:50:21] shouldn't matter what kind of loop you use
<seidos>	[Jun 20 20:51:02] Snova,  hmmm, how long do you think it should take for someone to figure out what is wrong with the while loop?
<Snova>	[Jun 20 20:51:19] as long as it takes and no more
<seidos>	[Jun 20 20:52:08] Snova, I ask because I want to utilize my time efficiently to learn.  I was thinking I could try some more, but if I can't figure it out could you take a look at my code?
<Snova>	[Jun 20 20:52:16] sure
<seidos>	[Jun 20 20:52:51] cool thanks, I'll ping you later if you don't mind
<bgs100>	[Jun 20 20:53:12] BACK
<bgs100>	[Jun 20 20:53:18] ...
<bgs100>	[Jun 20 20:53:22] Sorry I took so long
<bgs100>	[Jun 20 20:53:27] :(
<Snova>	[Jun 20 20:53:36] "a few minutes"
<pedro3005>	[Jun 20 20:53:46] we missed you :p
<bgs100>	[Jun 20 20:55:48] oh good :
<bgs100>	[Jun 20 20:55:49] :p
<bgs100>	[Jun 20 20:56:15] Maybe we're not having class today? x|
<pedro3005>	[Jun 20 20:56:40] bgs100, if you can, I'm up
<Snova>	[Jun 20 20:56:50] everyone's here; it just won't likely be as long
<bgs100>	[Jun 20 20:56:50] seidos ?
<bgs100>	[Jun 20 20:56:57] Indeed
<bgs100>	[Jun 20 20:57:07] probably just an hour
<seidos>	[Jun 20 20:57:23] yeah, bgs100
<bgs100>	[Jun 20 20:57:39] Okay then.
<bgs100>	[Jun 20 20:58:03] First, a review of functions (since we've done a little with them already)
<bgs100>	[Jun 20 20:59:18] So yeah
<bgs100>	[Jun 20 20:59:33] Time for the machine analogy :p
<bgs100>	[Jun 20 21:00:09] Functions are like machines that take in things (or, well, copies of things) and may or may not spit out things.
<seidos>	[Jun 20 21:00:14] can I invite other to the class?
<bgs100>	[Jun 20 21:00:15] brb
<seidos>	[Jun 20 21:00:19] s/other/others
<bgs100>	[Jun 20 21:00:19] seidos, sure
<bgs100>	[Jun 20 21:01:43] alright
<bgs100>	[Jun 20 21:01:48] so yeah
<bgs100>	[Jun 20 21:01:57] The general form of a function:
<bgs100>	[Jun 20 21:02:43] returntype functionname(sometype parameter1, sometype parameter2, ...) {
<bgs100>	[Jun 20 21:02:49]     functionbody
<bgs100>	[Jun 20 21:03:08]     possibly return statements inside
<bgs100>	[Jun 20 21:03:11] }
<bgs100>	[Jun 20 21:03:48] Okay?
<pedro3005>	[Jun 20 21:03:54] yes
<seidos>	[Jun 20 21:04:01] okay
<bgs100>	[Jun 20 21:04:25] If you don't want a function to return anything, you just declare it as type void.
<bgs100>	[Jun 20 21:05:06] mmmmmm
<bgs100>	[Jun 20 21:05:09] I know
<bgs100>	[Jun 20 21:05:21] Time to learn about: Recursion
<bgs100>	[Jun 20 21:06:00] seidos, pedro3005
<seidos>	[Jun 20 21:06:01] brb
<bgs100>	[Jun 20 21:06:05] Go to this page: http://www.google.com/search?q=recursion
<pedro3005>	[Jun 20 21:06:15] Yeah, I know it :p
<bgs100>	[Jun 20 21:06:21] Lol
<bgs100>	[Jun 20 21:06:35] seidos, Go there when you get back then :p
<seidos>	[Jun 20 21:09:54] okay back
<bgs100>	[Jun 20 21:10:48] seidos, clicked?
<seidos>	[Jun 20 21:11:00] yeah
<seidos>	[Jun 20 21:11:03] was even reading it a bit
<bgs100>	[Jun 20 21:12:02] Okay
<bgs100>	[Jun 20 21:12:04] seidos,
<bgs100>	[Jun 20 21:12:14] Did you click the "Did you mean?" text
<bgs100>	[Jun 20 21:12:17] ?
<seidos>	[Jun 20 21:12:21] no
<seidos>	[Jun 20 21:12:29] it was spelled right
<seidos>	[Jun 20 21:12:48] recursion and recursion, I saw no difference with the spelling
<seidos>	[Jun 20 21:12:55] looked kind of weird
<bgs100>	[Jun 20 21:13:08] Yes, that was the point
<seidos>	[Jun 20 21:13:09] so I clicked on the wikipedia article, bgs100
<pedro3005>	[Jun 20 21:13:14] lol he fell for it like a duck
<bgs100>	[Jun 20 21:13:14] Nooo
<seidos>	[Jun 20 21:13:31] oh I get it
<bgs100>	[Jun 20 21:13:32] seidos, The point was to notice the Did you mean? section :P
<seidos>	[Jun 20 21:13:35] it's recursive
<bgs100>	[Jun 20 21:13:39] Yes!
* bgs100 [Jun 20 21:13:49] gives seidos a star of new understanding
* bgs100 [Jun 20 21:14:04] gives pedro3005 a star of, uh, old understanding I guess
<bgs100>	[Jun 20 21:14:13] Okay
<bgs100>	[Jun 20 21:14:18] Pastebining some stuff
<pedro3005>	[Jun 20 21:14:35] one question, does Python allow for recursion?
<bgs100>	[Jun 20 21:14:54] Yes
<bgs100>	[Jun 20 21:15:00] However
<bgs100>	[Jun 20 21:15:11] Certain Lisps allow for infinite recursion ;)
* bgs100 [Jun 20 21:15:30] sends subliminal lisp propaganda
<bgs100>	[Jun 20 21:15:35] http://paste.pocoo.org/show/227823/
<bgs100>	[Jun 20 21:15:38] SCRO
<bgs100>	[Jun 20 21:15:40] Also
<bgs100>	[Jun 20 21:15:47] No, it won't give you the factorial of 9000
<pedro3005>	[Jun 20 21:16:08] bgs100, is lisp actually useful for real-world programming?
<bgs100>	[Jun 20 21:16:18] ...yes...
<Snova>	[Jun 20 21:16:30] pedro3005: I can't name a modern language that doesn't support recursion
<bgs100>	[Jun 20 21:16:30] pedro3005, Reddit was originally written in it! :P
<bgs100>	[Jun 20 21:16:55] Snova, Yes, but what languages can you name that support infinite tail-call recursion? :P
<pedro3005>	[Jun 20 21:16:57] hm, I thought it was just conceptual
<bgs100>	[Jun 20 21:17:06] ...
<seidos>	[Jun 20 21:17:14] 890! is 0
<bgs100>	[Jun 20 21:17:23] seidos, TRY A SMALLER NUMBER
<Snova>	[Jun 20 21:17:28] pedro3005: uh, Lisp has been around for decades; it still does things no other language can
<bgs100>	[Jun 20 21:17:33] THE C GODS DO NOT LIKE YOUR LARGE NUMBERS
<pedro3005>	[Jun 20 21:17:35] RuntimeError: maximum recursion depth exceeded
<pedro3005>	[Jun 20 21:17:40] damn it python
<bgs100>	[Jun 20 21:17:42] pedro3005, lol
<seidos>	[Jun 20 21:17:49] 10! = 3628800
<pedro3005>	[Jun 20 21:18:07] Snova, it is the one with all the parentheses, right?
<bgs100>	[Jun 20 21:18:07] pedro3005, wwwiiittthhh liiissppp aaannnddd taaaiill cccaaalllsss yyooouu woont hhaaavvee tthhaaatt prrobblleemmm
<bgs100>	[Jun 20 21:18:13] pedro3005, Yes >:|
<pedro3005>	[Jun 20 21:18:26] well, back to C
<bgs100>	[Jun 20 21:18:32] :[
<bgs100>	[Jun 20 21:18:41] No, no, we can stay on lisp is you want...
<bgs100>	[Jun 20 21:18:45] if*
<Snova>	[Jun 20 21:19:00] another day :p
<pedro3005>	[Jun 20 21:19:01] this is a C class
<bgs100>	[Jun 20 21:19:04] really, no trouble at all :P
<bgs100>	[Jun 20 21:19:12] pedro3005, Yeah, just kidding ;p
* pedro3005 [Jun 20 21:19:16] slaps bgs100 
<pedro3005>	[Jun 20 21:19:18] C TIME
<bgs100>	[Jun 20 21:19:21] HEY
* bgs100 [Jun 20 21:19:28] slaps pedro3005 with teacher yardstick
<bgs100>	[Jun 20 21:19:30] er
<bgs100>	[Jun 20 21:19:32] meterstick
<seidos>	[Jun 20 21:19:48] weird
<bgs100>	[Jun 20 21:19:53] seidos, hm?
<bgs100>	[Jun 20 21:20:38] Anyway
<bgs100>	[Jun 20 21:20:46] You will notice that factorial() calls itself
<bgs100>	[Jun 20 21:20:56] Hey
<bgs100>	[Jun 20 21:21:02] Try entering a reaaally big number
<pedro3005>	[Jun 20 21:21:04] IF n > 1
<pedro3005>	[Jun 20 21:21:06] :p
<pedro3005>	[Jun 20 21:21:23] bgs100, what's the point of infinite recursion anyway?
<bgs100>	[Jun 20 21:21:23] what?
<bgs100>	[Jun 20 21:21:26] pedro3005,
<bgs100>	[Jun 20 21:21:33] You can use it as opposed to loops
<pedro3005>	[Jun 20 21:21:50] Python allows for infinite loops
<bgs100>	[Jun 20 21:21:57] Well I would hope so
<pedro3005>	[Jun 20 21:22:00] so if you stick a finite recursion in an infinite loop
<bgs100>	[Jun 20 21:22:04] pedro3005, Not like that, though
<pedro3005>	[Jun 20 21:22:06] voil√°
<seidos>	[Jun 20 21:22:10] the recursion
<bgs100>	[Jun 20 21:22:19] I do not mean that you would use it to recurse infiniteley,
<bgs100>	[Jun 20 21:23:05] it's just that while recursion in other languages would blow your stack where a loop may not, in languages with tail-call optimization/recursion it won't.
<bgs100>	[Jun 20 21:23:14] Well
<bgs100>	[Jun 20 21:23:19] If it's the tail-call
<bgs100>	[Jun 20 21:23:50] ANYWAY
<bgs100>	[Jun 20 21:24:01] We'ren't you the one yelling "BACK TO C"?
<bgs100>	[Jun 20 21:24:05] Weren't*
<bgs100>	[Jun 20 21:24:11] ...stupid keyboard
<pedro3005>	[Jun 20 21:24:19] ok
<pedro3005>	[Jun 20 21:24:21] back to
<pedro3005>	[Jun 20 21:24:22] C
<bgs100>	[Jun 20 21:24:26] sooo yyeeahh
<bgs100>	[Jun 20 21:24:33] functions are pretty simple
<bgs100>	[Jun 20 21:24:40] moving on
<bgs100>	[Jun 20 21:24:51] unless there are any questions?
<bgs100>	[Jun 20 21:24:54] seidos, pedro3005 ?
<seidos>	[Jun 20 21:25:09] I can't think of any, though I should probably have at least 10
<pedro3005>	[Jun 20 21:25:15] I understand it
<bgs100>	[Jun 20 21:25:24] Cool then
<bgs100>	[Jun 20 21:25:29] ARRAY TIME!!!
<pedro3005>	[Jun 20 21:25:45] business time
<bgs100>	[Jun 20 21:25:49] ...?
<bgs100>	[Jun 20 21:25:51] anyway
<bgs100>	[Jun 20 21:25:54] So...
<bgs100>	[Jun 20 21:26:08] Starting off, I will first say the arrays are actually pointers.
<bgs100>	[Jun 20 21:26:12] that*
<bgs100>	[Jun 20 21:26:56] You declare an array like so:
<bgs100>	[Jun 20 21:27:09] int aBunchOfNumbers[9000];
<bgs100>	[Jun 20 21:27:42] General form: sometype arrayname[numberofarrayelements];
<bgs100>	[Jun 20 21:27:48] However
<bgs100>	[Jun 20 21:28:01] Declaring them this way just gets you a fixed size
<bgs100>	[Jun 20 21:28:32] So if you needed to make an array bigger, you probably get into pointers + malloc/realloc.
<bgs100>	[Jun 20 21:29:11] The address than an array holds (since it is a pointer) is something it already has.
<bgs100>	[Jun 20 21:29:38] It points to a chunk in memory, with the size depending on the data type and the numbers of elements.
<bgs100>	[Jun 20 21:30:18] Like "int blarg[5];" is the size of an integer times 5.
<bgs100>	[Jun 20 21:30:30] Questions so far from pedro3005 and seidos?
<pedro3005>	[Jun 20 21:31:03] nope. I'd like an example of array enlargement
<pedro3005>	[Jun 20 21:31:09] :p
<bgs100>	[Jun 20 21:31:19] Okay.
<seidos>	[Jun 20 21:31:22] when you say "chunk in memory" is it like 1MB, then each array elementy is x bytes?
<seidos>	[Jun 20 21:31:41] s/elementy/element
<bgs100>	[Jun 20 21:32:14] seidos, Er, if the total size of the array was 1024/1000 kilobytes
<bgs100>	[Jun 20 21:32:34] which would be over 1 million bytes...
<bgs100>	[Jun 20 21:32:49] Hopefully you would not have quite so large an array :p
<seidos>	[Jun 20 21:32:54] so 1MB is way too much
<seidos>	[Jun 20 21:33:00] got ya'
<bgs100>	[Jun 20 21:33:08] Pretty much xP
<seidos>	[Jun 20 21:33:09] I wonder how big the arrays are in firefox
<bgs100>	[Jun 20 21:33:18] *rolls eyes*
<bgs100>	[Jun 20 21:33:37] One sec
<bgs100>	[Jun 20 21:33:47] Getting array enlargment example for pedro.
<bgs100>	[Jun 20 21:38:02] brb
<seidos>	[Jun 20 21:45:35] sudo apt-get source firefox didn't work :(
<seidos>	[Jun 20 21:45:55] it must be because my ubuntu install is all screwy
<pedro3005>	[Jun 20 21:46:56] bgs100, "a few minutes" again :p
<bgs100>	[Jun 20 21:47:00] OHAI
<bgs100>	[Jun 20 21:47:06] ...slight difficulties
<pedro3005>	[Jun 20 21:47:12] no problem
<pedro3005>	[Jun 20 21:47:28] if it's something personal, you can stop the class
<bgs100>	[Jun 20 21:47:33] No, lol
<seidos>	[Jun 20 21:48:25] if the teacher is gone for 15 minutes, the class is over :P
<Snova>	[Jun 20 21:48:56] *ahem*
<bgs100>	[Jun 20 21:49:15] ?
<Snova>	[Jun 20 21:50:14] as, uh, assistant teacher I can prevent this class from ending :p
<bgs100>	[Jun 20 21:50:29] Lol
<pedro3005>	[Jun 20 21:50:45] anyway, array enlargement
<bgs100>	[Jun 20 21:50:51] pedro3005, Anyway, here ya go: http://paste.pocoo.org/show/227831/
<seidos>	[Jun 20 21:50:55] I bet SQL has some HUGE arrays
<seidos>	[Jun 20 21:51:00] well, maybe it depends
<bgs100>	[Jun 20 21:51:02] lol
<Snova>	[Jun 20 21:51:35] seidos: why?
* bgs100 [Jun 20 21:51:38] promotes Snova to Town Elder (teacher)
<pedro3005>	[Jun 20 21:51:58] bgs100, can you also use sizeof() as a sort of len() as Python?
<Snova>	[Jun 20 21:52:04] pedro3005: no
<Snova>	[Jun 20 21:52:08] well, yes
<Snova>	[Jun 20 21:52:09] but no
<bgs100>	[Jun 20 21:52:12] Lol
<pedro3005>	[Jun 20 21:52:20] like, to figure out the size of an array
<Snova>	[Jun 20 21:52:30] pedro3005: only if you already know the size anyway
<seidos>	[Jun 20 21:52:53] wth, that's crazy talk
<bgs100>	[Jun 20 21:53:04] pedro3005, With fixed arrays, usually, I think. With manually allocated stuff... it's very and not a good idea. Actually it's not a good idea anyway.
<bgs100>	[Jun 20 21:53:12] it's very iffy*
<pedro3005>	[Jun 20 21:53:14] Snova, so how can you figure out the size of an unknown array?
<Snova>	[Jun 20 21:53:14] sizeof() is evaluated at compile time, and C does not bound arrays. if you already know the size of the array (which is to say, the compiler knows) then you will get a correct answer
<Snova>	[Jun 20 21:53:20] pedro3005: you can't
<Snova>	[Jun 20 21:53:24] pedro3005: who's to say the array ends at all?
<bgs100>	[Jun 20 21:53:31] pedro3005, You must have so value marking the end
<bgs100>	[Jun 20 21:53:33] some*
<bgs100>	[Jun 20 21:53:37] stupid keyboard >:|
<seidos>	[Jun 20 21:53:40] but how would you not know the size of the array?
<seidos>	[Jun 20 21:53:55] don't you have to declare it?
<pedro3005>	[Jun 20 21:53:58] maybe you received it as argument in a generic function
<Snova>	[Jun 20 21:53:58] arrays don't exactly have sizes
* bgs100 [Jun 20 21:54:09] gives pedro3005 a star
<bgs100>	[Jun 20 21:54:22] In fact
<pedro3005>	[Jun 20 21:54:24] :D
<bgs100>	[Jun 20 21:54:35] The value-marking -the-end is exactly how strings work
<Snova>	[Jun 20 21:54:36] if you run "int a[30]" then it will be initialized to have 30 elements, but if you access a[31] it won't stop you and it will probably work too
<pedro3005>	[Jun 20 21:55:23] you have got to be kidding me
<Snova>	[Jun 20 21:55:28] arrays are blocks of memory. nothing more. there's no associated length with them; only how long you *THINK* it is
<bgs100>	[Jun 20 21:55:46] pedro3005, No, Snova isn't.
* bgs100 [Jun 20 21:56:11] speaks for Snova :p
<pedro3005>	[Jun 20 21:56:15] so what's the point of having the cute little number in front of it?
<bgs100>	[Jun 20 21:56:30] So it will allocate some blocks behind the scenes for you.
<Snova>	[Jun 20 21:56:31] as you mentioned you could declare a function "void f(int x[])" and pass it anything at all; it doesn't know how long it is and you can not find out
<seidos>	[Jun 20 21:56:38] Snova, what about how much page file and memory you have installed in your computer?
<seidos>	[Jun 20 21:57:14] arg, this is all crazy talk!  :P
<Snova>	[Jun 20 21:57:15] pedro3005: that's how big you defined it to be. obviously at about that point you know it has 30 elements, but it might as well be unbounded for all C will care
<pedro3005>	[Jun 20 21:57:17] bgs100, so you know that int a[30] has a length of at least 30?
<bgs100>	[Jun 20 21:57:29] uh, 29 :P
<bgs100>	[Jun 20 21:57:35] Er
<bgs100>	[Jun 20 21:57:37] nvm that
<Snova>	[Jun 20 21:57:39] pedro3005: you know that at least 30 elements are accessible; anything beyond that is uncharted territory
<bgs100>	[Jun 20 21:57:40] Thinking of indexing
<bgs100>	[Jun 20 21:57:48] pedro3005, What Snova said :P
<seidos>	[Jun 20 21:57:50] Snova,  so why not define all arrays as a[1], if it doesn't matter and you can access a[2000] anyway?
<Snova>	[Jun 20 21:57:52] seidos: not relevant as only some of that is allocated to you at all
<Snova>	[Jun 20 21:58:02] seidos: I just said it would probably work. not that it would be valid.
<bgs100>	[Jun 20 21:58:13] seidos, It is not guaranteed to be free and yours.
<Snova>	[Jun 20 21:58:18] and by the time you start accessing memory 2 megabytes past your stack you probably aren't in your memory anymore
<bgs100>	[Jun 20 21:58:31] SEGMENTATION FAULT!
* bgs100 [Jun 20 21:58:33] dies
<pedro3005>	[Jun 20 21:58:39] computers are so weird
<seidos>	[Jun 20 21:58:39] I don't own all my memory?
<bgs100>	[Jun 20 21:58:44] pedro3005, lol
<seidos>	[Jun 20 21:58:49] my computer has rebelled!
<Snova>	[Jun 20 21:58:50] seidos: your program doesn't, at least not until it asks for more of it
<bgs100>	[Jun 20 21:58:50] seidos, Your array does not
<Snova>	[Jun 20 21:58:54] hence the use of malloc()
<seidos>	[Jun 20 21:58:58] I get it, ubuntu is taking up memory, etc.
<pedro3005>	[Jun 20 21:59:02] "this is no man's memory now, baby"
<bgs100>	[Jun 20 21:59:08] x|
<seidos>	[Jun 20 21:59:25] I don't get the connection with malloc()
<pedro3005>	[Jun 20 21:59:34] malloc() allocates memory
<Snova>	[Jun 20 21:59:44] when your program starts it is given exactly enough memory to fit its binary. when you start using malloc(), more is allocated to it as needed. if you go much farther than your boundaries, then you're touching things that don't belong to you, and your program is killled
<bgs100>	[Jun 20 22:00:01] killled
<seidos>	[Jun 20 22:00:01] but arrays allocate memory too
<bgs100>	[Jun 20 22:00:03] :p
<Snova>	[Jun 20 22:00:08] seidos: not exactly
<bgs100>	[Jun 20 22:00:22] :|
<seidos>	[Jun 20 22:00:30] ah
<seidos>	[Jun 20 22:00:37] arrays don't "allocate" memory
<seidos>	[Jun 20 22:00:41] they do something else with memory
<Snova>	[Jun 20 22:00:46] if you type "int a[30]" then you're making room for 30 ints, and it will belong to you. but the chances are really, really good that a[31] also belongs to you, but purely by coincidence
<seidos>	[Jun 20 22:00:52] what?  not point.  fill maybe?
<Snova>	[Jun 20 22:00:54] seidos: there's more than one place you can get memory
* bgs100 [Jun 20 22:01:08] goes to Best Buy
<Snova>	[Jun 20 22:01:13] haha
* bgs100 [Jun 20 22:01:14] buys some RAM
<seidos>	[Jun 20 22:01:20] that's what I was thinking.
<bgs100>	[Jun 20 22:01:20] :P
<seidos>	[Jun 20 22:01:30] I mean the amount of memory resources on my computer are finite
<Snova>	[Jun 20 22:01:36] have you ever wondered where the memory for your "int x;" comes from? malloc() isn't involved; it manages something else
<seidos>	[Jun 20 22:01:37] isn't it all in a giant pool?
<seidos>	[Jun 20 22:02:02] I just assumed when you asked the OS for memory, and if it had any, it would give it to you
<bgs100>	[Jun 20 22:02:07] seidos, Eh, perhaps, but it is a pool that is very, very sectioned
<bgs100>	[Jun 20 22:02:16] seidos,
<seidos>	[Jun 20 22:02:22] so it's more like a bunch of kiddie pools
<Snova>	[Jun 20 22:02:23] normal variables, which is to say everything that doesn't involve malloc(), come from the stack, which is used for local variables and function calls
<seidos>	[Jun 20 22:02:31] and you have to ask for permission to play in any one of them?
<bgs100>	[Jun 20 22:02:47] seidos, The reason is so that one program can't bring down your whole computer by getting a bunch of memory.
<Snova>	[Jun 20 22:02:54] when you call malloc(), it uses the heap, which it manages by itself. when it needs more memory than available in the heap, it asks the OS to make it larger
<bgs100>	[Jun 20 22:03:00] Or messing with places it should not
<seidos>	[Jun 20 22:03:10] hmmm, that could be a virus
<seidos>	[Jun 20 22:03:19] a program that just asks for a bunch of memory
<Snova>	[Jun 20 22:03:22] I'm not making sense and I don't know what I'm explaining anymore
<Snova>	[Jun 20 22:03:24] we started at arrays
<bgs100>	[Jun 20 22:03:47] seidos, e.g. You can't suddenly make yourself 1st place in super tux kart with another program by messing with memory
<Snova>	[Jun 20 22:04:02] the point: arrays have a length that you set, but it's up to you to stay within its boundaries, and if you don't keep track of what those boundaries are, you're at fault if something goes wrong
<bgs100>	[Jun 20 22:04:10] *boom*
<bgs100>	[Jun 20 22:04:18] ohlook
* bgs100 [Jun 20 22:04:30] notices time
<Snova>	[Jun 20 22:04:39] sizeof() only knows the size of an array because the compiler is smart enough to figure it out in some cases
<Snova>	[Jun 20 22:04:43] and often, it doesn't
<Snova>	[Jun 20 22:05:00] so generally I would say don't use sizeof on arrays
<Snova>	[Jun 20 22:05:19] I honestly don't know what it's supposed to return in such cases; only that it can't always know
<bgs100>	[Jun 20 22:05:57] Also, as you probably know, you can access the members of an array by saying: array[somenumber]. The first element of an array is at array[0], not array[1]
<bgs100>	[Jun 20 22:06:05] So...
<bgs100>	[Jun 20 22:06:10] Homework time
<bgs100>	[Jun 20 22:06:28] Please turn your homework in pedro3005 and seidos (*tries to remember what homework was*)
<Snova>	[Jun 20 22:06:39] HoMeWoRk
<bgs100>	[Jun 20 22:06:44] Oh yeah!
* bgs100 [Jun 20 22:06:49] thanks Snova 
<pedro3005>	[Jun 20 22:07:01] shit
<bgs100>	[Jun 20 22:07:04] ...
<pedro3005>	[Jun 20 22:07:08] I think I just overwrote it
* bgs100 [Jun 20 22:07:12] removes pedro3005's star
<bgs100>	[Jun 20 22:07:19] Ohhh
<pedro3005>	[Jun 20 22:07:21] wait, I'll get it
<bgs100>	[Jun 20 22:07:21] :|
<pedro3005>	[Jun 20 22:07:50] yeah, I have it
<bgs100>	[Jun 20 22:07:53] Lol, once I accidentally compiled a program with the binary location set to the source code.
<Snova>	[Jun 20 22:07:54] ah, apparently C defines it as illegal to perform a sizeof() operation on undefined types
<pedro3005>	[Jun 20 22:07:56] bgs100, worry not, my lad
<Snova>	[Jun 20 22:08:07] i.e. if you don't tell the compiler how long an array is, sizeof() won't tell you
<bgs100>	[Jun 20 22:08:09] Lad? I'm the teacher.
<Snova>	[Jun 20 22:08:11] because it doesn't know
<mohi1>	[Jun 20 22:08:13] hey guys........ now only i reached home ^_^
<bgs100>	[Jun 20 22:08:21] Ohai mohi1
<seidos>	[Jun 20 22:08:41] here's mine:  http://paste.ubuntu.com/452730/
<mohi1>	[Jun 20 22:08:47] bgs100: sup?? your way of teaching is cool B-)
<bgs100>	[Jun 20 22:09:25] mohi1, Glad you think so B-)
* bgs100 [Jun 20 22:09:33] plans not to use that emoticon again
<seidos>	[Jun 20 22:10:11] B-) is the coolest emoticon ever
<pedro3005>	[Jun 20 22:10:55] bgs100, http://paste.pocoo.org/show/227756/
<bgs100>	[Jun 20 22:11:23] seidos, Nice... Simple, has a comment describing what it does... compiles without warning... has (some :p) indentation...  and does the bonus that I said
<Snova>	[Jun 20 22:11:24] OH MY GOD
<Snova>	[Jun 20 22:11:29] joking; looks good
<bgs100>	[Jun 20 22:11:30] Snova, ???
<bgs100>	[Jun 20 22:11:33] oh
<bgs100>	[Jun 20 22:11:35] >:|
<seidos>	[Jun 20 22:11:43] I had help :|
<bgs100>	[Jun 20 22:11:54] seidos, Oh, from who/what?
* seidos [Jun 20 22:12:00] points at pedro3005 
<bgs100>	[Jun 20 22:12:12] :|
<bgs100>	[Jun 20 22:12:23] wait what kind of help? :p
<seidos>	[Jun 20 22:12:41] I was stuck, so he let me see his source code
* pedro3005 [Jun 20 22:13:02] hides
<Snova>	[Jun 20 22:13:03] pedro3005: int IsEven(int check) { return !(check % 2); } // this works too
<Snova>	[Jun 20 22:13:16] seidos: did you learn something from it?
<seidos>	[Jun 20 22:13:34] Snova, heck yeah.  I even got close to solving the first euler problem
<Snova>	[Jun 20 22:13:38] well ok then
<seidos>	[Jun 20 22:13:46] but that was a fail too, I was off by 1000 for some reason
<seidos>	[Jun 20 22:13:56] hopefully we can go over that while loop after class
<bgs100>	[Jun 20 22:14:00] Alright
<Snova>	[Jun 20 22:14:06] programming is hard! throwing math in makes it harder
* bgs100 [Jun 20 22:14:12] will let it pass this time :p (jk)
<seidos>	[Jun 20 22:14:42] I should be a whiz at math, I took four semester of calculus in college.  D, B, B, C
<seidos>	[Jun 20 22:14:51] I took linear algebra too, but got a C :(
<seidos>	[Jun 20 22:15:02] s/semester/semesters
<bgs100>	[Jun 20 22:15:16] pedro3005, Good, works, and quite good style, and you did both the normal bonus and your own.
<seidos>	[Jun 20 22:15:17] and by whiz, I'm not sure what I mean :P
<bgs100>	[Jun 20 22:15:19] Actually
<bgs100>	[Jun 20 22:15:25] I notice something in both...
<bgs100>	[Jun 20 22:15:42] Although you kept a count, you did not print it at the end.
<seidos>	[Jun 20 22:15:53] bgs100, you should have seen what I was trying to do before pedro3005 looked at my code
<pedro3005>	[Jun 20 22:15:59] That was not in the requirements
<pedro3005>	[Jun 20 22:16:01] >:(
<bgs100>	[Jun 20 22:16:07] pedro3005, It was a bonus
<Snova>	[Jun 20 22:16:10] well that's -10 points
<seidos>	[Jun 20 22:16:12] ah, that's true, I tried to print it but couldn't figure out how
<bgs100>	[Jun 20 22:16:14] And you did almost all of it
<Snova>	[Jun 20 22:16:15] but you were at 120 already
<bgs100>	[Jun 20 22:16:21] Snova, Lol
* bgs100 [Jun 20 22:16:49] gives seidos and pedro3005 X's for failing at bonus!
<bgs100>	[Jun 20 22:16:54] X for Xcellent :P
<seidos>	[Jun 20 22:16:55] I can see pedro3005's point, printing was implied
<seidos>	[Jun 20 22:17:09] but I don't think anyone said "print the count"
<bgs100>	[Jun 20 22:17:18] seidos, Er, I'm pretty sure I did
* seidos [Jun 20 22:17:22] tries to add a print statement again, I know I tried but it didn't work for some reason
<bgs100>	[Jun 20 22:17:32] Anyway, I think he was saying that it was a bonus and not a requirement
<pedro3005>	[Jun 20 22:17:38] bgs100, no you didn't!
<bgs100>	[Jun 20 22:17:43] pedro3005, orly
<seidos>	[Jun 20 22:17:48] bgs100, it doesn't matter to me if you did, it was *at least* implied since I tried to do it
<pedro3005>	[Jun 20 22:17:56] well, I don't remember it, at least
* bgs100 [Jun 20 22:18:05] rolls eyes at pedro3005 
* bgs100 [Jun 20 22:18:20] gives seidos a star for not arguing :p
<seidos>	[Jun 20 22:18:42] please don't give me a star for being docile
<seidos>	[Jun 20 22:18:50] viva la revolucion!
<bgs100>	[Jun 20 22:18:53] I was joking :|
* seidos [Jun 20 22:18:59] hops on a table with his musket
<bgs100>	[Jun 20 22:19:13] Hmmm we need a dictator
* bgs100 [Jun 20 22:19:24] recalls Snova being a harsh dictator :p
<seidos>	[Jun 20 22:19:25] we have a dictator, his name is bgs100 :D
<seidos>	[Jun 20 22:19:54] we have to fight with our C programming skills
<bgs100>	[Jun 20 22:20:26] I hope you saved the old topic
<pedro3005>	[Jun 20 22:20:42] bgs100, I am a dictator, not stupid
<bgs100>	[Jun 20 22:20:47] lol
* bgs100 [Jun 20 22:21:02] shoots lightning out of his fingers at seidos 
* seidos [Jun 20 22:21:31] agonizes
<bgs100>	[Jun 20 22:21:32] Okay
<seidos>	[Jun 20 22:21:33] Father please!
<bgs100>	[Jun 20 22:21:38] uh
<bgs100>	[Jun 20 22:21:45] I'm the emperor *sigh*
<bgs100>	[Jun 20 22:21:52] Homework for tonight:
<bgs100>	[Jun 20 22:22:44] Get some numbers from input (you can pick how many... or even get the number by other means), store them in some kind of array, and print the sum.
<seidos>	[Jun 20 22:22:47] who else tortures people with lightning from fingers for having too much lip?
<bgs100>	[Jun 20 22:22:55] Lol
* seidos [Jun 20 22:23:10] creates a file
* bgs100 [Jun 20 22:23:12] is still the emperor, so whatever
<bgs100>	[Jun 20 22:23:19] Actually
<seidos>	[Jun 20 22:23:28] there's still good in you, I can feel it
<bgs100>	[Jun 20 22:24:07] uhh
* bgs100 [Jun 20 22:24:14] zaps the good in me with lightning
<bgs100>	[Jun 20 22:24:18] fixed
<seidos>	[Jun 20 22:24:28] hahaha
* seidos [Jun 20 22:25:06] ponders
<seidos>	[Jun 20 22:25:10] so that's how he did it
<bgs100>	[Jun 20 22:25:19] xD
<bgs100>	[Jun 20 22:25:22] Anyway
* bgs100 [Jun 20 22:25:40] zaps the lesson with lightning
<bgs100>	[Jun 20 22:25:43] The lasson is over
<bgs100>	[Jun 20 22:25:46] lesson*
* bgs100 [Jun 20 22:25:54] zaps keyboard with lightning
<seidos>	[Jun 20 22:26:58] hey, bgs100 can you help me with my while loop?
<bgs100>	[Jun 20 22:27:03] BTW "<Snova> programming is hard! throwing math in makes it harder" <--- Tell the Haskell people that :D
<Snova>	[Jun 20 22:27:06] hahaha
<bgs100>	[Jun 20 22:27:13] seidos, Sure
<Snova>	[Jun 20 22:27:15] "I am a dictator, not stupid"
<seidos>	[Jun 20 22:27:16] or Snova (I thought you left)
<Snova>	[Jun 20 22:27:24] briefly
* bgs100 [Jun 20 22:28:15] waits...
<seidos>	[Jun 20 22:28:16] here's the code:  http://paste.ubuntu.com/452737/
<***>	Playback Complete.
-NickServ-	[Jun 20 00:27:34] mohi1!~devil@117.201.27.39 has just authenticated as you (mohi1)
-NickServ-	[Jun 20 22:06:27] mohi1!~devil@117.201.18.231 has just authenticated as you (mohi1)
-*status-	Welcome to 57o9's ZNC service. Need help? try ##5709 on Freenode (irc.freenode.net) or #shell on our IRC server (trogdor.57o9.org) Both on port 6667.
-*status-	Reminder: All 57o9 shell users are required to represent themselves on our IRC server (stated above). Be sure to be there to make sure your account is not locked.
-*status-	If you have a shell and you are connecting on irc.57o9.org, make sure you have the right vhost, ask J for more infos.
<seidos>	bgs100 ^
<seidos>	here's the euler problem:  http://projecteuler.net/index.php?section=problems&id=1
<seidos>	my answer is too high by 1000
<bgs100>	Uhh
<bgs100>	seidos,
<seidos>	can't figure out why
<bgs100>	Repkace the "|" with "||"
<bgs100>	Replace*
<bgs100>	That should fix it
<seidos>	all right, I'll try that
<bgs100>	Considering the || is logical or and | is bitwise or...
<bgs100>	x|
<seidos>	no, answer is still 234168
<seidos>	should be 233168
<Snova>	bgs100: wouldn't make a difference (though it is wrong)
<bgs100>	Oh
<bgs100>	:p
<Snova>	that is a funny way to be wrong. exactly 1000?
<seidos>	incidentally, the for loop at the bottom works according to pedro
<seidos>	Snova, that's what I was thinking
<Snova>	oh, I have an idea
* seidos listens
<Snova>	seidos: move x++ to after the body of the loop
<seidos>	Snova, so not inside the loop?
<Snova>	the while condition keeps it below 1000, but when it's at 999 you increment it
<Snova>	no, inside, but at the end
<seidos>	okay
<Snova>	you're accidentally processing 1000, as it's divisible by 5
<pedro3005>	bgs100, what is with all the "bitwise" thing? I always see people talking about it
<bgs100>	pedro3005, Okay,
<Snova>	pedro3005: 42 is 101010
<pedro3005>	oh, binary
<bgs100>	It is has to do with the binary that internally represents your number.
<Snova>	pedro3005: bitwise operators are simply those which mess with  bits
<seidos>	Snova, yeah, that fixed it.
<seidos>	I need to remember that in c, order matters
<Snova>	pedro3005: there are four (I think)- | & ^ ~
<bgs100>	pedro3005, For example, bitwise or,
<Snova>	seidos: order always matters.
<pedro3005>	Snova, I think >> also, no?
<Snova>	pedro3005: oh, there's also >> and <<, yes
<Snova>	[Jun 20 22:33:14] pedro3005: | takes two bits and returns 1 if either of them are 1; if both are 0 then you get 0. it's "or"
<seidos>	[Jun 20 22:33:21] Snova, I used to think scripted languages were more sensitive to order than compiled languages.  Not so in any way, shape, or form?
<Snova>	[Jun 20 22:33:30] pedro3005: & is and; if both input bits are 1 then you get 1. otherwise it's 0
<Snova>	[Jun 20 22:33:49] pedro3005: ^ is "exclusive or", which returns 1 only if *only one* input bit is 1, otherwise 0.
<mohi2911>	[Jun 20 22:33:51] bgs100, saw the logs??
<Snova>	[Jun 20 22:34:00] pedro3005: ~ flips the bit; 1 becomes 0 and 0 becomes 1
<bgs100>	[Jun 20 22:34:06] Take 0110 (6) and 1010 (10). Bitwise or of them is: 1110
<Snova>	[Jun 20 22:34:14] pedro3005: << and >> shift bits around; 0110 << 1 = 1100
<bgs100>	[Jun 20 22:34:16] (I think :p)
<bgs100>	[Jun 20 22:34:18] mohi2911, ?
<Snova>	[Jun 20 22:34:21] looks right
<bgs100>	[Jun 20 22:34:28] yay
<Snova>	[Jun 20 22:34:36] seidos: doesn't make sense to me
<pedro3005>	[Jun 20 22:34:40] Snova, and these are useful?
<Snova>	[Jun 20 22:34:43] pedro3005: for some things
<seidos>	[Jun 20 22:34:45] Snova, all right, thanks
<Snova>	[Jun 20 22:35:06] pedro3005: generally no, but there are occasions where it is useful to be able to touch individual bits
<Snova>	[Jun 20 22:35:13] pedro3005: bitflags are a useful example
<Snova>	[Jun 20 22:36:22] pedro3005: a rather common pattern is several different "flags", either 1 or 0, that can be present at the same time. if each flag is a bit, you can store 32 different flags in one int
<Snova>	[Jun 20 22:36:57] it's simple to manipulate, space efficient, and fast
<pedro3005>	Snova, so is there some way to grab the first bit of an int, like it was an array?
<mohi2911>	bgs100, https://wiki.ubuntu.com/learners
<Snova>	pedro3005: the "first" bit can mean two things- least significant or most significant
<pedro3005>	oh yeah
<Snova>	pedro3005: "least significant" is the one you can twiddle to make it odd or even. binary 1 is "1", 2 is 10... the one on the right would be the least significant, because if a bit randomly twiddles itself, that one will change the value the least
<Snova>	all of a sudden I'm giggling at the word "twiddles"
<Snova>	bit twiddling
<Snova>	pedro3005: anyway, to get the least significant bit you can simply & it with 1. if the bit is set, all other bits will be masked except that one. if it's zero, the rest are all still masked, but now that one is too... so 1101 & 1 = 0001 and 1100 & 1 = 0000
<Snova>	the one on the far left is slightly trickier; the simplest way is just to shift it right. for a 32-bit integer (int): i >> 31 & 1
<seidos>	I don't get how 1101 & 1= 0001
<Snova>	pedro3005: also, since the least significant bit is 1, you can use it as a fast even/odd test
<Snova>	seidos: 1101 & 0001. when it tests the first two bits, only one of them is 1, so the "and" test fails. when it gets to the last one, both of them are 1, so the "and" test succeeds and spits out a "1". so 1101 & 0001 = 0001
<seidos>	I get 1101 & 0001 = 0001
<Snova>	<seidos> I don't get how 1101 & 1= 0001 <-- well this is the same thing, I just left out some zeros
<seidos>	Snova, yeah, I see that now.  when I first trying to figure it out I tried 1101 & 1000...but that didn't work, didn't think to try 1101 & 0001.  I suppose it has something to do with bit significance, yes?
<seidos>	s/I/I was
<Snova>	seidos: 1101 & 1000 = 1000
<seidos>	yeah that makes sense
<Snova>	"least significant" and "most significant" is just a somewhat less ambiguous way to say "right bit and left bit"
<seidos>	"least significant" is the bit to the power of 1?
<Snova>	yes
<seidos>	most significant is to the power of 32 in a 32 bit system?
<Snova>	yes
<pedro3005>	Snova, I actually read a discussion online today about if & 1 is faster than % 2
<seidos>	I also forget if least significant is to the power of 0 or 1
<pedro3005>	seemed like the answer was "no"
<Snova>	changing a number by a factor of 2^1 isn't much, but 2^32 is rather larger
* seidos nods
<Snova>	pedro3005: theoretically it would be faster (no math involved) but you should also ask whether the compiler is doing that already
<seidos>	is the c compiler written in assembly?
<Snova>	not to mention it's really hard to measure speed differences at such a minute scale; modulus might take a few extra nanoseconds, but who's going to notice? it may as well be background noise if you're profiling
<Snova>	seidos: no modern ones are
<Snova>	seidos: question: what do you write an assembler in? :)
<seidos>	Snova, so they're written in c?
<pedro3005>	binary?
<Snova>	pedro3005: where did the binary editor come from?
<seidos>	Snova, machine code?
<Snova>	seidos: whatever language is handy, really. gcc is C (they're moving to C++) and LLVM is C++
<pedro3005>	Snova, little electrical signals?
<seidos>	Snova, a chip?
<Snova>	I imagine once upon a time C compilers might have been assembly, or they may have been self-compiling, but now we already have C compilers, so we can use them to make more
<pedro3005>	so there's a C interpreter built into my computer?
<seidos>	self-compiling?
<seidos>	we use c compilers to make more c compilers
<Snova>	or, we use humans
<seidos>	what's the point in having a different c compiler than the original?  does the language change?
<Snova>	C was a lot simpler initially; if you wrote a correct C compiler in C, it would not have been nearly as big as today's. you could compile it by hand, by running its own code through it on paper!
<Snova>	it's one way of doing it anyway; I don't know. you'd have to ask whoever did it the first time
<Snova>	seidos: quite substantially
<seidos>	then you'd have the 0's and 1's and could flip a switch on your computer to enter the code?
<Snova>	I think they might have been a little more advanced by then, but I guess
<seidos>	pedro3005 is right,  computers are weird
<seidos>	they might as well be magic
<Snova>	they are. but we like them anyway
<pedro3005>	it's so... ingenious
<seidos>	it kind of creeps me out how abstracted away I am from it
<Snova>	we build tomorrow's tech on today's. we're long past the point where we could recreate today's stuff from scratch
<seidos>	I mean, it just shows how there are much smarter people out there than I am
<seidos>	Snova, that's kind of freaky
<Snova>	we aren't just building on previous things; as the really old stuff stops being used it ceases to exist
<seidos>	what would we do without computers?
<Snova>	it's like standing on top of the tower you're building, but the bottom is disappearing
<pedro3005>	Snova, so aren't there some really outdated stuff we're depending upon
<pedro3005>	?
<seidos>	oh...my...science
<Snova>	pedro3005: nobody needs it
<pedro3005>	but everything is built on top of it
<Snova>	pedro3005: well, yes, I heard the traffic lights in DC stopped working when a computer several decades old finally died
<Snova>	pedro3005: ah, but with it, we build replacements for it
<seidos>	well, if you knew that computers are at least possible
<seidos>	you could at least spend some time *trying* to build it from scratch
<pedro3005>	It's just incredible how a bunch of wires plugged together can create this new world
<seidos>	I mean, if we lost everything we've built up to now, but still had the knowledge we retained
<Snova>	they're too complicated. cpu's are running into quantum physics problems now
<seidos>	we probably still have schematics for old stuff stored somewhere
<Snova>	your knowledge wouldn't last long enough to recreate even our basic tools
<seidos>	humanity built it from scratch before
<Snova>	we've had a long time to do it
<Snova>	well...
<pedro3005>	So it's humanly impossible to know how a computer works completely?
<seidos>	like a hundred years?
<Snova>	come to think of it most of today's tech was invented in the last few hundred years...
<seidos>	300 years sounds like a long time
<Snova>	pedro3005: maybe not impossible, but there's a lot more dteails than any one person would have the time to digest[1;5Dabsorb, I think
<Snova>	that was weird
<seidos>	what was that?
<pedro3005>	one 30-year-old bit misbehaving, most likely
<pedro3005>	:P
<seidos>	well, how important are computers anyway?
<seidos>	so people won't be able to use twitter anymore
<pedro3005>	pretty important
<seidos>	so what if our entire financial system is dependent on them
* Snova_ (~kitty@unaffiliated/snova) has joined ##learners
<seidos>	stock markets crash
<Snova_>	having weird connection problems...
<pedro3005>	it would be the end of modern society
<seidos>	is someone trying to hack you?
<Snova_>	mine is fine, but the server snova is connected from is lagging a lot
<seidos>	but you *are* snova!  kidding
<seidos>	I should've been a farmer
<seidos>	too bad it's so much damn work
<Snova_>	not sure about that
<seidos>	it's probably more work than learning computers
<Snova_>	mainstream farming is nearly completely automated in some cases
<seidos>	are you serious?
<pedro3005>	see, even farming is done by computers today
<seidos>	dude, this is creepy
<Snova_>	quite
<pedro3005>	we'd all die if computers stop working
<seidos>	it's like the matrix, we're dependent on the technology now
<seidos>	there ain't no going back
<seidos>	pedro3005, not all of us
<Snova_>	really now. depending on the time of year and the crop, your job as a farmer may well consist of sitting in an air conditioned room and telling a computer what chemicals you want to dump on the plants today
<Snova_>	fun
<Snova>	here we go
<seidos>	even if farming is automated, I bet the farmers wouldn't die if an electronmagnetic pulse took out all our electronics
<Snova_>	the ones working on monocultured farms for large corporations might
* Snova_ has quit (Client Quit)
<pedro3005>	well, society would definitely collapse
<Snova>	the ones that hang on to older traditions are nearly self-sufficient
<pedro3005>	so we'd turn into cavemen
<seidos>	Snova, the farmers working for monocultured farms probably have a better shot at survival than I do.  I am way too disassociated from the farms
<Snova>	seidos: maybe. on the other hand I don't think they can live on corn
<pedro3005>	computers better keep working for years to come
<seidos>	Snova, is that the monocultured farms?  do they only grow corn?
<seidos>	pedro3005, amen
<seidos>	but it does make AI a little scarier
<Snova>	seidos: not necessarily, just an example. corn is something of a staple crop though
<seidos>	I probably should've been more scared of y2k than I was
<seidos>	Snova, they could probably survive on corn long enough to grow some limes to fight off the scurvy
<Snova>	hah
<seidos>	man, survival is nuts
<seidos>	it's so much easier to just die
<seidos>	well, depends on how you die
<seidos>	starving to death probably isn't very easy
<Snova>	"slow and tedious" probably doesn't do it justice
<seidos>	I can barely go without food for two days
<pedro3005>	how about "slow and despairing"
<seidos>	how about slow, tedious, and despairing?
<Snova>	how about "two weeks of slowly dying"?
<seidos>	I thought you could live a couple weeks longer than that without food
<seidos>	like 30 days
<seidos>	water, different story
<pedro3005>	our mistake here was looking at death as an end to the constant struggle of life, whereas death itself appears to be a struggle
<Snova>	I don't know; you want to die for four weeks straight?
<seidos>	have you guys seen sunshine?  at least I think that's what it's called
<Snova>	not in a few hours :p
<Snova>	mostly moonlight right now
<Snova>	anyway
<Snova>	we are not learning C anymore
<seidos>	Snova, it's a movie
<pedro3005>	yes, we aren't
<seidos>	yeah, pedro3005 and I get sidetracked talking about philosophy and junk
<Snova>	that may have been my fault
<pedro3005>	hey, who cares... let's no be so strict
<seidos>	Snova, what do you do with your C programming knowledge?
<seidos>	or any language
<Snova>	seidos: the odd small program that needs to run faster than usual and explaining it to other people; not much
<pedro3005>	hah
<seidos>	Snova, can you give an example of a small program you work on?
<pedro3005>	so we work our asses off for years so at the end we can sit down and think "hell yeah, I know C... I wonder what's on reddit today"
<Snova>	seidos: at the moment I have two "real" projects in python; one is an irc bot I've had going for far too long and I'm also trying my hand at game programming
<Snova>	oh, I was messing with a webapp the other day as well (it needs significant work)
<Snova>	generally, "whatever sounds fun"
<seidos>	Snova, oh, I see.  I suck at programming bots.  I tried to take pedros bot and program it to talk to me, but that was a fail
<seidos>	you can't use C for web apps, right?
<Snova>	why not?
<pedro3005>	it's compiled, I guess
<Snova>	no reason
<Snova>	so is java, and asp.net
<seidos>	I didn't think there was any interface for it
<seidos>	or something
<pedro3005>	so you can?
<seidos>	like, how does it run in a web browser?
<Snova>	it doesn't, exactly...
<pedro3005>	server-side?
<seidos>	so I could put my HW in this class on the web somehow?
<Snova>	client-side the only thing you really have available to you is JavaScript, Flash, Silverlight, and the like
<pedro3005>	that reminds me of a paste website that runs your code
<Snova>	(Silverlight can actually do a lot more than this that makes what I just said untrue, but meh)
<Snova>	server-side anything goes. why not? after all, it's your server
<seidos>	I wouldn't know how to get apache to server my c binaries
<Snova>	the reason you don't see much C on the web is because it's hard to secure, easy to screw up and speed generally doesn't matter /that/ much
<seidos>	I don't have an apache server anyway though
<seidos>	s/server/serve
<Snova>	most web servers today interface with webapps using some kind of protocol; it used to be CGI, now SCGI/FastCGI/etc. are common
<Snova>	it doesn't matter what language is running the program on the other end, so long as there is a program there
<seidos>	I know nothing about CGI
<seidos>	but PHP doesn't use CGI, does it?
<Snova>	it means Common Gateway Interface, and it is a way for http servers (e.g. apache) to communicate with programs that generate web pages
<seidos>	hmmm none of my programs generate web pages
<seidos>	I thought there might be something along this avenue
<Snova>	as such any program at all can implement CGI, and if the web server is appropriately configured and the program able to understand it, then that program can be said to be "on the web"
<seidos>	I mean the idea is to learn to program, then to develop an application, or learn an application that has already been developed
<Snova>	PHP is usually deployed with mod_php, an apache module that embeds the php interpreter directly into the web server process- which is much more efficient than CGI
<seidos>	man
<seidos>	so it sounds like if you want to do web programming, C really isn't the language to do it in
<Snova>	not really. it's kind of a pain for this kind of work
* Snova_ (~kitty@unaffiliated/snova) has joined ##learners
<seidos>	I'm trying to figure out how C can benefit me
<Snova_>	oh come on
<seidos>	can I use c programming to fix your internet access?
<seidos>	:D
<Snova_>	it's not mine :|
<seidos>	it's not your Internet access?
<Snova>	no, my connection's fine
<seidos>	man computers is a huge field
<Snova>	however, the server that this client is running off of is having issues
<seidos>	ohhh
<Snova>	it's not going down, and it's still accessible... an irc bot also running here responds, for example, but it took it four seconds
<pedro3005>	seidos, it's like philosophy.. knowledge for knowledge
<pedro3005>	C for C
<seidos>	yeah, I guess.  well, learning one thing should help your ability to learn other things
<Snova>	C is useful to know because if all you've programmed in is python, you'll never look at a computer the same way again
<seidos>	though I'm not sure that philosophy really has helped me learn better, pedro3005
<pedro3005>	yeah... from now on I look at them like "please don't break"
<Snova>	hahaha
<seidos>	Snova, can you give an example of how a person would look at the computer?  like, too abstracted?
<seidos>	pedro3005, man that's true
<seidos>	I don't do that nearly enough
<seidos>	my laptop's ac adapter broke
<seidos>	I can't even build an ac adapter
<seidos>	I was lucky enough to be able to fix the problem by soldering some wires though
<pedro3005>	see... I can't even solder a wire
<seidos>	soldering a wire is easy, you can solder a wire
<seidos>	you could learn it in like 2 minutes
<Snova>	seidos: if you see "x = foo()" in python you'd be tempted to say it is a method call, but it's more. it's a stack-based virtual machine interpreting bytecode, allocating objects on the heap and dispatching methods; it is the C runtime managing its heap; it is the operating system managing its memory and hardware; it is the CPU fetching and executing millions of instructions by converting them to microcode...
<seidos>	Snova, you might as well have told me that the sound of one hand clapping is the tao
<Snova>	even if you never, ever program at a lower level than "x = foo()", there are reasons to know what is happening underneath that, because it can influence how you do things on top of it
<pedro3005>	ok, goodnight
<Snova>	good night :)
<seidos>	good night pedro
<seidos>	hmmm interesting
<seidos>	I'll have to read what you wrote like 10 times to probably even get *close* to knowing what it means
<seidos>	and by close I mean "just scratch the surface"
<Snova>	heh, the point is there's a lot going on. you don't even have to know how it works (I have only an overview), but know that it's there
<seidos>	yeah, I'm not sure what I know is there?
<seidos>	er
<seidos>	s/?/NULL
<Snova>	well, you've used python. now you're learning what python is made of
<Snova>	if you were to learn assembly you'd find out what C is made of
<seidos>	that's the problem though
<seidos>	I've *used* python, but I haven't learned it
<seidos>	I can't say I *know* python, or c, or any programming language, really
<seidos>	I have the most experience writing SQL, but I can't say that I *know* that either, I never wrote any stored procedures
* pedro3005 has quit (Ping timeout: 245 seconds)
<seidos>	I dunno, I'm not really sure what I know.  I few snippets here and there, but they don't seem to coalesce into any kind of substantial understanding
<Snova>	and underneath it all, is zen
<seidos>	I don't get zen.  I'm going to a Therevada monastery though in July
<Snova>	it's converting languages into languages all the way down
<seidos>	Theravada, sorry
<seidos>	that figures, I suck at languages
<seidos>	I only speak English
<seidos>	I'm terrible at Spanish (even though my mom speaks it)
<seidos>	and I'm bad at Math
<seidos>	I sometimes wonder if my deficiencies are genetic, or if everyone has this difficult a time learning new things
<seidos>	I trip out when I read about scientists that "teach themselves" language
<Snova>	hm?
<seidos>	I should get to work on HW
<Snova>	here is a question: what is compilation?
<seidos>	translation (I first wanted to say conversion) of a language to machine code
<seidos>	so maybe it's all language
<seidos>	hmmm
<Snova>	machine code is its own language. and you don't have to compile to that
<seidos>	so what is the best way to learn language?
<Snova>	the python interpreter "compiles" python code into a bytecode, which is much simpler than python, and only runs on its own "processor"- python
<seidos>	so compilation isn't translating c into machine language?
<Snova>	it doesn't /have/ to be
<seidos>	if it's not translating to another language, what is it doing
<seidos>	and how is python a processor?
<Snova>	it has an instruction set, just like a cpu
<seidos>	whoa, that's weird
<seidos>	an instruction set
<Snova>	we invent languages on a daily basis to express our problems in; python is merely another one of those- a language designed to be used to create langauges for us to solve problems with
<seidos>	hmph
<seidos>	so your saying python is a language that *creates* language
<Snova>	there is a templating language called Jinja2 which is used to generate html pages. it's written in python, and it works by converting the template into python
<Snova>	I can therefore say that python is a language that has been used, by jinja, to create a language- the template syntax- which is used to solve a certain subset of problems- generating html
<seidos>	well python was written in C so I guess that kind of makes sense
<Snova>	even a processor has an internal instruction set
<Snova>	it's called microcode; it's like a little mini-cpu
<seidos>	so python has a copy of this instruction set?
<seidos>	or does it have its own?
<seidos>	microcode.
<Snova>	the python interpreter converts Python code into its own bytecode, and then runs it
<seidos>	I should look that up
<Snova>	it's simply faster that way
<Snova>	https://secure.wikimedia.org/wikipedia/en/wiki/Microcode
<seidos>	so microcode is another layer of language?
<seidos>	well code isn't necessarily language, is it?
<Snova>	code is, by definition, instructions specified to a computer in a certain syntax
<seidos>	ah, instructions
<seidos>	that's true, language isn't necessarily instructions
<seidos>	kind of makes me wonder what good is it for then
<Snova>	makes it easier to express our intent
<Snova>	expressing html generation in, say, assembly code would be rather tedious
<seidos>	firmware, says here that IBM calls microcode + machinecode in hardware as  firmware
<Snova>	well ibm is weird then
<seidos>	here's the whole line:  Some hardware vendors, especially IBM, use the term as a synonym for firmware, so that all code in a device, whether microcode or machine code, is termed microcode (such as in a hard drive for instance, which typically contains both).[1]
<seidos>	but that kind of makes sense.  firmware doesn't always contain machine code
<seidos>	like those programmable chips
<Snova>	the point is, to express our desires, creating a language tailored to the problem domain is helpful
<seidos>	where you can program and gates and or gates and stuff
<Snova>	anyway
<Snova>	too much head hurting; I'm going to go play a game for a while :p
<seidos>	all right
<seidos>	thanks for the lesson
* mohi2911 plays with Snova 
* Snova invites mohi2911 down the rabbit hole
* mohi2911 gets in and bites Snova 
<Snova>	we have electrons down here at the bottom
<mohi2911>	Wow
</pre>
