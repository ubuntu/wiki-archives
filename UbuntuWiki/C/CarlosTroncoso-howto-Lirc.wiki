{|
| '''Warning'''
* This is a '''readonly''' and '''text-based''' archive of a deprecated wiki.
* '''Images''' and '''attachments''' have been removed to conserve space.
* '''Links''' may not work and there may be formatting issues.
* A '''compressed''' version with images and the original syntax is in the repo '''Releases'''.
|}

__TOC__

== Howto Lirc ==
Created Tuesday 18 November 2008

Lirc es un <nowiki>[[daemon]]</nowiki> que permite traducir señales infrarojas de controles remotos, en mensajes que linux pueda comprender.

Este howto apunta a configurar lirc para las tradicionales tarjetas de TV que incluyen control remoto.
Linux soporta la gran mayoría de estas tarjetas, y configuradas correctamente, los controles remotos deberían funcionar sin necesidad de configuración. Pero cuando digo "funcionar", es respecto a que generen eventos.

En linux, algunos de los dispositivos (devices), son del tipo entrada (input), tales como el teclado, mouse, tabletas graficas y controles remotos. Aun cuando Lirc fué ideado para usar como dispositivo de entrada  un sensor infrarojo por puerto serial, existen modulos que permite a Lirc, leer de otras fuentes, como por ejemplo, "devinput", que lee de "/dev/input/eventX".

=== Aspectos Técnicos ===
Si los aspectos técnicos no te interesan, puedes saltarte esta sección.

El proceso presionar un boton en el control remoto, hasta que llega como señal comprensible a la salida (socket) de lirc, es el siguiente.

1. Boton presionado en control remoto 
2. Señal infraroja enviada por el aire 
3. Recepción por interfaz infraroja
4. Kernel recibe la señal
6. El modulo de kernel de lirc atrapa la señal
7. Lirc procesa la señal
8. Emite el resultado al unix socket de Lirc.

Veamos los puntos que nos interesan.

==== Punto 6 - Módulos de kernel (Kernel Modules) ====
Lirc requiere comunicarse con el kernel, y lo hace a travez de módulos. Puedes tener muchos modulos de kernel para Lirc cargados, aunque los script de inicialización de lirc los pueden cargar bajo demanda.

==== Punto 7 - Lircd (Lirc Daemon) ====
Lircd requiere de 2 datos para operar, el driver y el dispositivo.
En nuestro caso, el driver a usar sera __devinput__.
El dispositivo será "/dev/input/event5", que es el que corresponde al control remoto.
No se preocupen, esto es solo la parte técnica. El __como__ se hace para saber que evento usar, lo explicaré mas abajo.

==== Punto 8 - Socket de Lirc ====
Si todo ha ido bien, Lirc ya debe estar leyendo, analizando y procesando, y emitiendo sus resultados al socket /dev/lircd (por omisión)

-------------------------------

=== Instalación general ===

Como buenos niños, vamos a despejar la mesa y traer los materiales que pidió el profesor.

==== Ingredientes ====
* Lirc
* Modulos de Kernel
* Tarjeta de TV configurada y funcionando con linux
* Cable con sensor IR (viene con la tarjeta)
* Control Remoto (viene con la tarjeta)

Vamos a asumir que ya saben usar un terminal, lineas de comando y los conceptos de Super Usuario (root), sinó, veamos si álguien se apiada de sus almas y escribe un tutorial de que es y como se usa __eso.__

Como nomenclatura standard, todo lo que comience por $, significa que es un comando que hay que escribir en el terminal. Para los mas flojonazos, un copiar-pegar igual les sirve.
Comencemos.
Bajar e instalar lirc

<pre>
$ sudo apt-get install lirc
</pre>

Bajar e instalar el modulo lirc para eventos

<pre>
$ sudo apt-get install inputlirc
</pre>

¡¡Bieeeen!! ¿Dolió mucho? No, ¿cierto?

Ahora hay que configurar al niño.
Los archivos a los que hay que meterle mano son:	
* /etc/lirc/hardware.conf
* /etc/lirc/lircd.conf

==== hardware.conf ====
Si miramos la documentación de lirc, no dice nada de ningún hardware.conf. De hecho, lirc solo se configura con lircd.conf. Entonces, ¿Que es este archivo y que hace?

Lirc no se manda solo, como buen servicio de linux, es __levantado__ por <nowiki>[[init]]</nowiki>, que es quien dice quien parte y quien no parte en los sistemas linux.

La forma de activar lirc es típicamente esta: 
	lircd [options] [config-file]
Asi, lo tradicional sería algo como esto:
	lircd --driver=devinput --device=/dev/input/event5
Todo eso son opciones, no es necesario especifigar el archivo de configuración [config-file], porque lirc asume que es /etc/lirc/lircd.conf. Hmmm, ¿Y que onda con el hardware.conf?

Ahora si que si. Como dije, ya que lirc no se manda solo, y lo levanta <nowiki>[[init]]</nowiki> mediante un script, es el script mismo el que construye el comando que activa a lirc.
Veamos un hardware.conf tipico.
<pre>
# /etc/lirc/hardware.conf
# 
# Chosen Remote Control
	REMOTE_DRIVER="devinput"
	REMOTE_DEVICE="/dev/input/event5"

# Don't start lircmd even if there seems to be a good config file
	START_LIRCMD="false"

# Try to load appropriate kernel modules
	LOAD_MODULES="true"

# Default configuration files for your hardware if any
# LIRCMD_CONF=""
</pre>
Bueno, cuando linux va a activar lirc, lo primero que hace <nowiki>[[init]]</nowiki> es leer este archivo y asi sabe lo que tiene que poner como opciones cuando active lirc.
Hay varias opciones, y ninguna documentada como la gente, por lo que hay que meterse bien dentro para saber cuales existen y como se usan. Ya se habran dado cuenta que lo que comience por # son solo comentarios, pero vamos a lo general.

Los 3 puntos claves en que hay que fijarse son:
* REMOTE_DRIVER
* REMOTE_DEVICE
* LOAD_MODULES

---------
REMOTE_DRIVER
es donde decimos que poner despues de __--driver=__

REMOTE_DEVICE
es donde decimos que poner despues de __--device=__ 

LOAD_MODULES ("true"|"false")
es para informar que queremos que se intente cargar los módulos de kernel, indicados en REMOTE_DRIVER. Puede ser "true" o "false". Bueno, de hecho, solo funciona si es "true", cualquier otra cosa se considera falso, incluso que no esté definido, poniendo un #al principio de la linea, para que la salte.
---------

Ehh, lo del driver me queda claro, devinput, pero, ¿Que pongo en device?
Buena pregunta.
Preguntemosle a linux.

<pre>
$ less /proc/bus/input/devices

  .....(muchas lineas antes)......
  I: Bus=0001 Vendor=1131 Product=2341 Version=0001
  N: Name="saa7134 IR (Encore ENLTV)"
  P: Phys=pci-0000:01:00.0/ir0
  S: Sysfs=/devices/pci0000:00/0000:00:1e.0/0000:01:00.0/input/input5
  U: Uniq=
  H: Handlers=kbd event5 
  B: EV=100003
  B: KEY=10a3cb10 2319082 0 0 0 8 318000 4180 104801 216c0 0 1 10008ffe
  .....(muchas lineas despues)......
</pre>
Wow! esto como que tiene sentido. Tarjeta Encore ENLTV, claro, la tarjeta de TV, menciona IR, infrarrojo, y si vemos en la H: dice ¡EVENT5!  ¡Justo lo que buscabamos!

Ahora ya sabemos que poner en REMOTE_DEVICE
	REMOTE_DEVICE="/dev/input/event5"

Ahora nos toca el round con el lircd.conf.
------------

==== lircd.conf ====
Este archivo es fabricado por otro programa, que gracias a los simpáticos creadores de lirc, lo incluyeron en el paquete. El gran y no muy bien ponderado <nowiki>[[irrecord]]</nowiki>.
irrecord es como un mini lirc, acepta casi las mismas opciones y nos va guiando paso a paso para crear un archivo de configuración.
lo vamos a activar de esta manera, recuerden que su event, depende de lo que hayan encontrado en el paso anterior.
Como este programa lo vamos a lanzar __a mano__, y usa el siguiente comando.

<pre>
$ irrecord --driver=devinput --device=/dev/input/event5 lircd.conf
</pre>

¿No funcionó?
Ohh, el driver (modulo) tal vez no esté cargado. ¡Carguemoslo!

<pre>
$ sudo modprobe devinput
</pre>

Ahora si. 
<pre>
$ irrecord --driver=devinput --device=/dev/input/event5 lircd.conf
</pre>

Irrecord irá haciendo preguntas y hay que ir respondiendo.
¿Cual es el nombre que quiere que tenga su control remoto?
Presione un boton.. mantengalo presionado
Presione un mismo boton varias veces lo más rápido que pueda.
Escriba el nombre de el primer boton.
Presione y mantenga presionado.
Nombre del segundo boton... etc.. 
Para terminar, en vez de escribir el nombre de un boton, solo presionen ENTER.

¡Y listo! irrecord escribió un archivo lircd.conf válido en el directorio en que estamos.
Ahora hay que copiarlo a su ubicación oficial.

<pre>
$ sudo cp lircd.conf /etc/lirc/
</pre>
-------------

==== Prueba final ====
Ya. Hora de probar si funciona.
Primero detenemos lirc, por si por alguna razón hubiese partido sin nuestro consentimiento.
<pre>
$ sudo /etc/init.d/lirc stop
</pre>

Y ahora a activarlo
<pre>
$ sudo /etc/init.d/lirc start
</pre>

Si vemos que nos dice __done!__, estamos impeque.
Lirc ya está funcionando.
¿Probemos?
<pre>
$ irw
</pre>

y comencemos a presionar botones en el control.
irw es un programa de prueba, pero que puede tener otras aplicaciones. 
Solo escribe exactamente lo que le llega a lirc.

<pre>
ctroncoso@alpha:~$ irw
	000000008001018b 00 1 Genius_A11
	0000000080010174 00 5 Genius_A11
	000000008001000f 00 6 Genius_A11
	00000000800100a8 00 0 Genius_A11
	0000000080010006 00 FullScrn Genius_A11
	000000008001016f 00 AvSource Genius_A11
	000000008001008b 00 Right Genius_A11
	0000000080010001 00 Left Genius_A11
	0000000080010071 00 Vol+ Genius_A11
	00000000800100ae 00 Vol- Genius_A11
</pre>
Para terminar la prueba, presionen Ctrl-C
"Pero quiero ver tele con esto!"
Tranquilo, Ahora viene la parte entretenida.
Ya que lirc es para multiples usuarios, tenemos otro archivo que configurar. __~/.lircrc__

.lircrc es un archivo oculto que está en la raiz de nuestra carpeta principal.
Este archivo es usado por varios programas para saber que hacer cuando se presiona un boton. Veamos 2 de los más importantes, irxevent e irexec y su archivo __.lircrc__.

Este es parte de mi archivo .lircrc<nowiki>[[.]]</nowiki> Como ven, puede tener comentarios (#) y bloques bien definidos con un begin y un end. Cada bloque tiene como minimo, 4 comandos. Estos los vemos a continuación.
<pre>	
# ##################
# ### Volume Control ####
# ##################
	
	begin
	        prog = irexec
	        button = Mute
	        config = amixer set Master mute &
	        config = amixer set Master unmute &
	        repeat = 0
	end
	
	begin
	        prog = irexec
	        button = Vol+
	        config = amixer set Master 2dB+ unmute &
	        repeat = 2
	end
	
	begin
	        prog = irexec
	        button = Vol-
	        config = amixer set Master 2dB- unmute &
	        repeat = 2
	end
</pre>
-----------------	
prog:  indica "a que programa responde este bloque"

button: A que boton respondo

config: ahi depende del programa en __prog__, en el caso de irexec, es el comando que debe ejecutarse. Si hay mas de un __config__, en un bloque, se ejecuta uno cada vez, partiendo por el primero.

repeat: Que hacer si una tecla se repite. 0 indica "ignore" , 2 indica "procese cada 2". Util para los volumenes. 
-----------------

Ya que irexec e irxevent responden al mismo archivo de configuración, es lógico que solo existan prog=irexec o prog=irxevent, pero como hay o pueden escribirse otros programas que lean el mismo archivo, ya mas adelante podrán haber otros prog= mas.
Recuerden que este archivo NO ES de lirc mismo, sinó de programas que USAN lirc. Lirc se limita a decir que se presionó, no que hacer.

Entonces, irexec ejecuta comandos, ¿y que hace irxevent? 
Irxevent simula que presionaste alguna tecla en una ventana.
Este es un bloque de .lircrc con una instrucción a irxevent.
<pre>
	begin
	        prog = irxevent
	        button = Ch_dn
	        config = Key Down Focus CurrentWindow
	        repeat = 0
	end
</pre>
Simple. Si presiono Ch_dn (canal abajo) simule que se presionó la tecla (key) flecha_abajo (Down) y envie enfoque (focus) ese evento a la VentanaActual (CurrentWindow). Repeat opera igual que siempre.

Con esto ya deberían poder activar y cerrar programas, subir y bajar volumenes, etc. 

-------

Cuando les quede clara la pelicula, verán que es posible hacer un sinnumero de cosas con lirc, incluso hay programas que reemplazan completamente al irexec y a irxevent, como el plircc, que tiene una gran gracia. Soporta estados. Osea, si estoy en estado "ver TV", quiero que si presiono power, se apague tvtime, pero como irxevent no tiene estados (al menos no son simples de realizar), se apagará tvtime, pero tambien se activará Mplayer, pq el mismo boton estaba definido para ambos programas, e irexec ejecuta TODO lo que calce en sus bloques. Plircc hace posible que puedan desactivar algunos bloques o restringir la ejecución a los bloques segun estado.

Espero que haya sido de ayuda y cualquier "addendum o fe de erratas", me las hacen llegar. 
Salu2!
