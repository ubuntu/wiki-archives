{|
| '''Warning'''
* This is a '''readonly''' and '''text-based''' archive of a deprecated wiki.
* '''Images''' and '''attachments''' have been removed to conserve space.
* '''Links''' may not work.
* A '''full compressed version''' of the wiki is available on archive.org
|}

__TOC__

=== Firmware Test Suite - acpitables test ===

This test sanity checks various fields in common ACPI tables against the <nowiki>[[http://www.acpi.info/DOWNLOADS/ACPIspec50.pdf|ACPI specification]]</nowiki> and will report any anomalies.  These test can be very pedantic and possibly flag errors that are worked around in the Linux kernel.

Typical output from this test is as follows:

<pre>
ACPI table settings sanity checks.
--------------------------------------------------------------------------------
Test 1 of 1: Check ACPI tables.
PASSED: Test 1, Table APIC passed.
PASSED: Test 1, Table ECDT passed.
FAILED [MEDIUM] FADT32And64BothDefined: Test 1, FADT 32 bit FIRMWARE_CONTROL is
non-zero, and X_FIRMWARE_CONTROL is also non-zero. Section 5.2.9 of the ACPI
specification states that if the FIRMWARE_CONTROL is non-zero then
X_FIRMWARE_CONTROL must be set to zero.

ADVICE: The FADT FIRMWARE_CTRL is a 32 bit pointer that points to the physical
memory address of the Firmware ACPI Control Structure (FACS). There is also an
extended 64 bit version of this, the X_FIRMWARE_CTRL pointer that also can point
to the FACS. Section 5.2.9 of the ACPI specification states that if the
X_FIRMWARE_CTRL field contains a non zero value then the FIRMWARE_CTRL field
* must* be zero. This error is also detected by the Linux kernel. If
FIRMWARE_CTRL and X_FIRMWARE_CTRL are defined, then the kernel just uses the 64
bit version of the pointer.

PASSED: Test 1, Table HPET passed.
PASSED: Test 1, Table MCFG passed.
PASSED: Test 1, Table RSDT passed.
PASSED: Test 1, Table RSDP passed.
Table SBST not present to check.
PASSED: Test 1, Table XSDT passed.

</pre>

The following ACPI tables are examined by this test:

{| class="wikitable"
|-
| APIC
| Multiple APIC Description Table
|-
| ECDT
| Embedded Controller Boot Resources Table
|-
| FACP
| Fixed ACPI Description Table (FADT)
|-
| FACS
| Firmware ACPI Control Structure
|-
| HPET
| IA-PC High Precision Event Timer Table
|-
| MCFG
| PCI Express memory mapped configuration space base address Description Table
|-
| RSDT
| Root System Description Table
|-
| RSDP
| Root System Description Pointer
|-
| SBST
| Smart Battery Specification Table
|-
| XSDT
| Extended System Description Table
|}

See section 5.2 of the ACPI specification for more details.

==== Examples: ====

<pre>
sudo fwts acpitables - 
</pre>

..runs the acpitables test on your machine and dumps the output to stdout.

<pre>
fwts acpitables --dumpfile=apcidump.dat -
</pre>

..runs the test using ACPI tables in the dump file acpidump.dat as the input and dumps the test results to stdout.

<pre>
sudo acpidump > acpidump.dat
fwts acpitables --dumpfile=acpidump.dat
</pre>

..dumps the tables using acpidump and loads them in and runs the test with results appended to results.log

<pre>
sudo fwts --dump
fwts acpitables --dumpfile=acpidump.log -
</pre>

..dumps the tables using fwts and loads them in and runs the test with results going to stdout.

=== Explanation of test results ===

Certain test results may require a little more explanation. This section will try and give some context to specific test failures.

{| class="wikitable"
|-
| Error ID
| Explanation
|-
| FADT32And64BothDefined
| The FADT FIRMWARE_CTRL is a 32 bit pointer that points to the physical memory address of the Firmware ACPI Control Structure (FACS).  There is also an extended 64 bit version of this, the X_FIRMWARE_CTRL pointer that also can point to the FACS.  Section 5.2.9 of the ACPI specification states that if the X_FIRMWARE_CTRL field contains a non zero value then the FIRMWARE_CTRL field *must* be zero.  This error is also detected by the Linux kernel.  If FIRMWARE_CTRL and X_FIRMWARE_CTRL are defined, then the kernel uses the 64 bit version of the pointer.
|-
| FADTBadPMTMRLEN
| FADT field PM_TMR_LEN defines the number of bytes decoded by PM_TMR_BLK. This fields value must be 4. If it is not the correct size then the kernel will not request a region for the pm timer block.
|-
| FADTBadRESETREG
| The FADT RESET_REG address space ID must be either System I/O space, System Memory space or PCI configuration spaces. If it is not set correctly then ACPI writes to this register *may* nor work correctly, meaning a reboot via this mechanism may not work.
|-
| Fw``Ctrl``32``and``64``Differ
| One would expect the 32 bit FIRMWARE_CTRL and 64 bit X_FIRMWARE_CTRL pointers to point to the same FACS, however they don't which is clearly ambiguous and wrong. The kernel works around this by using the 64 bit X_FIRMWARE_CTRL pointer to the FACS.
|-
| HPETVendorIdZero
| <nowiki>[[http://www.intel.com/hardwaredesign/hpetspec_1.pdf|The HPET specification]]</nowiki> describes the HPET table in section 3.2.4 'The ACPI 2.0 HPET Description Table (HPET)'. The top 16 bits of the Event Timer Block ID specify the Vendor ID and this should not be zero.  This won't affect the kernel behaviour, but should be fixed as it is an undefined ID value.
|-
| HPETBaseZero
| The HPET specification describes the HPET table in section 3.2.4 'The ACPI 2.0 HPET Description Table (HPET)'. A zero (NULL) base address for a HPET will possibly lead to a misconfigured HPET if the kernel derives its HPET configuration from this table at a later date.
|}
