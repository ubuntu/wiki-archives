{|
  | '''Warning'''
  * This is a '''readonly''' and '''text-based''' archive of a deprecated wiki.
  * '''Images''' and '''attachments''' have been removed to conserve space.
  * '''Links''' may not work and there may be formatting issues.
  * A '''compressed''' version with images and the original syntax is in the repo '''Releases'''.
|}

__TOC__



== Overview ==

This page represents our best attempt at gathering the common tools and practices used by engineers on the Ubuntu Foundations team.

== Development ==

=== Emacs ===

We are in alphabetical order, right?! =)

* <nowiki>[[http://emacswiki.org/emacs/|EmacsWiki]]</nowiki>
* * <nowiki>[[http://www.emacswiki.org/emacs/PythonProgrammingInEmacs| PythonProgrammingInEmacs]]</nowiki> - for pyflakes, rope, etc.
* * <nowiki>[[http://www.emacswiki.org/emacs/CollectionOfEmacsDevelopmentEnvironmentTools|CEDET]]</nowiki> - for IDE like features

=== Vim ===

==== Plugins ====

Turns Vim into a fully-functional IDE:

* <nowiki>[[http://www.vim.org/scripts/script.php?script_id=3302|clang_complete]]</nowiki>
* <nowiki>[[http://vim.sourceforge.net/scripts/script.php?script_id=642|GetLatestVimScripts]]</nowiki>
* <nowiki>[[http://vim.sourceforge.net/scripts/script.php?script_id=610|ctags]]</nowiki>
* <nowiki>[[http://www.vim.org/scripts/script.php?script_id=893|gtags]]</nowiki>
* <nowiki>[[http://www.vim.org/scripts/script.php?script_id=184|vtreeexplorer]]</nowiki>
* <nowiki>[[http://www.vim.org/scripts/script.php?script_id=152|ShowMarks]]</nowiki>
* <nowiki>[[http://www.vim.org/scripts/script.php?script_id=2368|CCTree]]</nowiki>
* <nowiki>[[http://www.vim.org/scripts/script.php?script_id=42|BufExplorer]]</nowiki>
* <nowiki>[[http://www.vim.org/scripts/script.php?script_id=273|taglist]]</nowiki>
* <nowiki>[[http://www.vim.org/scripts/script.php?script_id=3431|AsyncCommand]]</nowiki>

== Testing and Debugging ==
=== Python ===

Use pyflakes to check for common errors. Hook this up to your preferred test harness using something akin to the following:

* <nowiki>[[http://bazaar.launchpad.net/~ubuntu-installer/ubiquity/trunk/view/head:/tests/run-pyflakes|run-pyflakes]]</nowiki>
* <nowiki>[[http://bazaar.launchpad.net/~ubuntu-installer/ubiquity/trunk/view/head:/tests/pyflakes.exclude|pyflakes.exclude]]</nowiki>
* <nowiki>[[http://wiki.python.org/moin/BarryWarsaw|pyflakes in Emacs buffers]]</nowiki>

<nowiki>[[http://www.voidspace.org.uk/python/mock/|Mock]]</nowiki> is one of the better mocking libraries and is already used in ubiquity, software-center, and apport.

<nowiki>[[http://pypi.python.org/pypi/ipdb|ipdb]]</nowiki> iPython like debugging shell with superior tab completion. <code>import ipdb; ipdb.set_trace()</code> is pure heaven.

=== C ===

==== Tracing ====

* `strace`: system call tracing.
* `ltrace`: library function tracing.
* `atrace.sh`: library function ''and'' application function tracing
   (http://people.canonical.com/~jhunt/scripts/atrace.sh).

==== Memory Checkers ====

Note: to use memory checkers reliably, you need to tell (e(g))libc and glib to disable all ''their'' checks too like this:

<pre> bash
export G_SLICE=always-malloc
export G_DEBUG=gc-friendly,resident-modules
export MALLOC_CHECK_=0
</pre>

Note the trailing underscore at the end of the last variable!

===== valgrind =====

No need to recompile code.

Basic memory checking:

<pre> bash
   valgrind -v myprogram --arg=foo -baz
</pre>

More aggressive checking:

<pre> bash
valgrind -v \
  --track-fds=yes \
  --log-file=/tmp/valgrind.log \
  --tool=memcheck \
  --leak-check=full \
  --track-origins=yes \
  --malloc-fill=0x0 \
  --free-fill=0x0 \
  --show-reachable=yes \
  myprogram --arg=foo -baz
</pre>

Deep magic which will spawn gdb when an error is detected (`--db-attach=yes`):

<pre> bash
valgrind \
  -v \
  --trace-children=yes \
  --track-fds=yes \
  --time-stamp=yes \
  --db-attach=yes \
  --read-var-info=yes \
  --tool=memcheck \
  --leak-check=full \
  --leak-resolution=high \
  --num-callers=40 \
  --show-reachable=yes \
  --track-origins=yes \
  --undef-value-errors=yes \
  --freelist-vol=60000000 \
  --malloc-fill=0x7 \
  --free-fill=0x8 \
  myprogram --arg=foo -baz
</pre>

===== dmalloc =====

Install:

<pre> bash
sudo apt-get install -y libdmalloc5 libdmalloc-dev
</pre>

<pre> bash
eval `dmalloc -b -i 1 -l /tmp/dmalloc.log all`
myapp --arg=foo -bar
cat /tmp/dmalloc.log
</pre>

Using dmalloc with LD_PRELOAD:

<pre> bash
(eval `dmalloc -b -i 1 -l /tmp/dmalloc.log all`; LD_PRELOAD=libmalloc.so.5; ./myapp --arg=foo -bar)
</pre>

===== wrap_malloc =====

Simpler more hackable/configurable tool than dmalloc/electric-fence:

http://people.canonical.com/~jhunt/utils/wrap_malloc/

==== Static Analysis ====

===== cppcheck =====

 <pre> bash
check:
    ...
    if type cppcheck >/dev/null 2>&1; then \
        cppcheck -v . --error-exitcode=1; \
    fi
 </pre>

===== splint =====

Excellent static analysis tool. May now be unmaintained? Does not understand C99 (variadic macros).
 <pre> bash
   splint -I/usr/include -I/some/where -DMY_DEFINE=1 -DFOO src/main.c 2>&1|tee splint.log
 </pre>
* LLVM/Clang
 <pre> bash
   sudo apt-get install -y clang
   scan-build -v -v -v make 2>&1|tee scan-build.log
 </pre>

===== smatch =====

<nowiki>[[http://smatch.sourceforge.net/|Smatch]]</nowiki> is a static analysis that uses Linus' <nowiki>[[https://sparse.wiki.kernel.org|sparse]]</nowiki> C parser.

 <pre> bash
   make clean
   make CHECK="smatch --full-path" CC="cgcc -std=gnu99"
 </pre>

=== Performance testing ===

* <nowiki>[[https://launchpad.net/judge|judge]]</nowiki> runs two commands 50 times and provides the following report:
<pre>
ubuntu@server-8149:~$ ./judge/judge ./2281 ./with_changes
v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^

    n mean sd min max cmd
   50 10316.2ms 355.7 9945.9 11638.6 ./2281
   50 9867.5ms 625.8 9385.6 13061.3 ./with_changes
 -448.636ms -4.3% p=0.000
difference is significant at 95.0% confidence (p=0.000):
based on these samples, suggested sample size is n>=283 to have a 112.16ms confidence interval
</pre>

=== Cloud infrastructure ===

<nowiki>[[https://help.ubuntu.com/community/CloudInit|cloud-init]]</nowiki> provides a means to run scripts during the creation of a Canonicloud instance. You can use this to create configurations for the infrastructure you need for a project and rapidly deploy that, either to develop or run tests against.  See the code in whoopsie-daisy as <nowiki>[[http://bazaar.launchpad.net/~ev/whoopsie-daisy/trunk/files/head:/backend/setup/|an example]]</nowiki>.

== Building ==

* sbuild (far superior to pbuilder: quicker per-build setup, closer to Launchpad buildd environment, integrates well with schroot for ad-hoc testing)

== Productivity ==

=== Efficiently splitting a terminal into several smaller windows ===

tmux is a terminal multiplexer, similar to GNU Screen, but <nowiki>[[http://tmux.svn.sourceforge.net/viewvc/tmux/trunk/FAQ|arguably better]]</nowiki>.

Some tips:
* The default keybindings let you use <code>^b arrow</code> to move between panes. However, because this is a sequence of keys rather than a modifier, you can easily get into timing issues where you meant to move to the pane above, then downward in the open file, but actually moved to the pane above and back into the previous one. You can fix this by telling tmux to not wait for commands:
 <pre>
 set -g escape-time 0
 </pre>
* You can bind a key to take the current tmux selection and put it in the X11 clipboard:
 <pre>
 unbind ^C
 bind ^C run "tmux show-buffer | xclip -i -selection clipboard"
 </pre>

 Using the standard keybindings, you would hit <code>^b^[</code> to enter copy mode, <code>^space</code> to mark the beginning of a selection, the arrow keys to mark the end, and alt-w to select. Then press <code>^b^c</code> to copy that text to the X11 clipboard.
