{|
| '''Warning'''
* This is a '''readonly''' and '''text-based''' archive of a deprecated wiki.
* '''Images''' and '''attachments''' have been removed to conserve space.
* '''Links''' may not work and there may be formatting issues.
* A '''compressed''' version with images and the original syntax is in the repo '''Releases'''.
|}

__TOC__


The !TouchSmart tm2 came originally in multiple versions in addition to custom made from HP-shop.
The two versions were tm2-1080 and tm2-1090; the differences between the two were the CPU (SU4100 vs. SU7300) and the amount of RAM (1+2=3 GB vs. 2+2=4 GB). There are also tm2-2050xx versions (tm2-2050us, tm2-2050ca, tm2-2050er, etc.).

 ~+Note+~<<BR>>
 These workarounds, solutions, and tips have been tested and verified to work on an HP !TouchSmart Tm2-2050us running Ubuntu 10.04 Lucid Lynx and Ubuntu 10.10 Maverick Meerkat. They have been tested but not verified for 11.04 Natty Narwhal.

== Installing Ubuntu 10.4 - 11.10 alongside Windows 7 ==
------
The !TouchSmart has four primary partitions when it ships. Hence, it is not possible to just resize and create a new partition - one of the existing ones must be deleted.

The "HP_TOOLS" seemed pretty useless, and as it only contained files for styling the diagnostics screen, this was chosen as the least useful, the files were backed up and the partition was deleted. Then the C-drive was resized so that it was approximately 30GB smaller, to use for Ubuntu.

 ~+Note+~<<BR>>
 The "HP_TOOLS" partition could be placed at USB flash drive, for more details see documentation for the various HP EFI tools installers (could be found in drivers download section for your product at HP support site).

Then I created a bootable memory stick with Ubuntu see <nowiki>[[https://help.ubuntu.com/community/Installation/FromUSBStick]]</nowiki>, booted (chose boot device by pressing [esc] right before the Windows 7-logo shows and by pressing boot select [F10]) and installed.

The display could occasionally stop working on the live USB/CD images, and at log in screen, this can be fixed by simply closing the display lid, and reopening it (this usually has to be done at least 2 or 3 times). In 11.04 it seem about every other boot up dose not allow you to do any thing just a black screen, no amount of closing and opening will fix this. In this case just restart your computer and try again. For fixing this very annoying bug see <nowiki>[[#Screen_Brightness|Screen Brightness]]</nowiki> section.

== Status of devices ==
------
Status of the devices of the laptop, which parts are working and which parts are not. Eventually how to fix the problems.

=== Graphics ===
-----
!TouchSmart tm2 has two GPUs onboard: integrated (Intel, less acceleration, more battery life/less heating and noise) and discrete (ATI, much faster acceleration, less battery life/more heat and noise). This is called hybrid graphics.

 ~+Note+~<<BR>>
 Disabling discrete GPU battery life improvement could be very impressing. For example, for tm2-2050xx battery time increases from about 3 hrs. to about 7 hrs.

You can get your !TouchSmart GPUs list by running:

<code>lspci | grep VGA</code>

There is a kernel mechanism available by default since Ubuntu 10.10 named <nowiki>[[#vga_switcheroo|vga_switcheroo]]</nowiki>, which makes possible to switch between GPUs.

==== Screen Brightness ====

There is a nasty bug somewhere between DSDT ACPI table and kernel, which (at least) sometimes takes internal display backlight off (which can be turned on back just with that close-lid-open-lid magic). It is already reported at launchpad (<nowiki>[[https://bugs.launchpad.net/ubuntu/+source/linux/+bug/697514|Bug #697514]]</nowiki>) and kernel.org (<nowiki>[[https://bugzilla.kernel.org/show_bug.cgi?id=34582|Bug 34582]]</nowiki>), but as for 2012-04-10 it is not processed yet.

There is workaround, though. DSDT can be fixed to remove error-causing block and brightness control will work almost perfectly. ''(Thanks to <nowiki>[[http://ubuntuforums.org/showthread.php?t=1647828|someh4x0r]]</nowiki> for debugging and <nowiki>[[http://blog.michael.kuron-germany.de/2011/03/patching-dsdt-in-recent-linux-kernels-without-recompiling/|Michael Kuron]]</nowiki> for pointing out DSDT patching technique using Grub2.)'' Following steps are tested with tm2-2050xx (BIOS versions F.05 and F.25) with Ubuntu 11.10.

'''1)''' Dump current DSDT table:

<code>sudo cat /sys/firmware/acpi/tables/DSDT > dsdt.dat</code>

'''2)''' Disassemble DSDT table getting <code>dsdt.dsl</code> file:

<code>iasl -d dsdt.dat</code>

 ~+Note+~<<BR>>
 If <code>iasl</code> command is not found you can install Install Intel ASL Optimizing Compiler using:<<BR>>
 <code>sudo apt-get install iasl</code>

'''3)''' Fix method <code>OBCL</code> in <code>dsdt.dsl</code> file (open it with your favorite text editor) to look like (just copy over the existing method text):

<pre>
                    Method (OBCL, 0, NotSerialized)
                    {
                        BINI ()
                        Return (Package (0x0D)
                        {
                            0x64, 
                            0x3C, 
                            0x06, 
                            0x0A, 
                            0x14, 
                            0x1E, 
                            0x28, 
                            0x32, 
                            0x3C, 
                            0x46, 
                            0x50, 
                            0x5A, 
                            0x64
                        })
                    }
</pre>

For example, the original method, that should be replaced with upper content, for current (2012-04-10) tm2-2050xx BIOS version F.25 looks like:

<pre>
                    Method (OBCL, 0, NotSerialized)
                    {
                        BINI ()
                        If (LEqual (IOSR, One))
                        {
                            Return (Package (0x0D)
                            {
                                0x64, 
                                0x3C, 
                                0x06, 
                                0x0A, 
                                0x14, 
                                0x1E, 
                                0x28, 
                                0x32, 
                                0x3C, 
                                0x46, 
                                0x50, 
                                0x5A, 
                                0x64
                            })
                        }
                        Else
                        {
                            Store (Package (0x0D)
                                {
                                    0x64, 
                                    0x3C, 
                                    Zero, 
                                    0x0A, 
                                    0x14, 
                                    0x1E, 
                                    0x28, 
                                    0x32, 
                                    0x3C, 
                                    0x46, 
                                    0x50, 
                                    0x5A, 
                                    0x64
                                }, Local0)
                            If (LEqual (OSYS, 0x07D6))
                            {
                                Return (Package (0x0D)
                                {
                                    0x64, 
                                    0x3C, 
                                    0x06, 
                                    0x0A, 
                                    0x14, 
                                    0x1E, 
                                    0x28, 
                                    0x32, 
                                    0x3C, 
                                    0x46, 
                                    0x50, 
                                    0x5A, 
                                    0x64
                                })
                            }

                            Return (Local0)
                        }
                    }
</pre>

'''4)''' Now save the <code>dsdt.dsl</code> file and assemble it getting <code>dsdt.aml</code> file:

<code>iasl -tc dsdt.dsl</code>

Compiler may report some warnings and even errors, but <code>dsdt.aml</code> file will be created (these are initially left by your product vendor). To be sure you correctly patched the method you can compare warning/error count for assembling your version <code>dsdt.dsl</code> and assembling unchanged one, their quantity should be equal.

'''5)''' Copy <code>dsdt.aml</code> to /boot/ and set permissions:

<pre>
sudo cp dsdt.aml /boot/
sudo chown root:root /boot/dsdt.aml
sudo chmod 644 /boot/dsdt.aml
</pre>

'''6)''' Open file with you favorite editor:

<code>gksudo gedit /etc/grub.d/01_acpi</code>

Paste the following code:

<pre>

GRUB_CUSTOM_ACPI="/boot/dsdt.aml"

prefix=/usr
exec_prefix=${prefix}
libdir=${exec_prefix}/lib

. ${libdir}/grub/grub-mkconfig_lib

if [ x${GRUB_CUSTOM_ACPI} != x ] && [ -f ${GRUB_CUSTOM_ACPI} ] \
        && is_path_readable_by_grub ${GRUB_CUSTOM_ACPI}; then
    echo "Found custom ACPI table: ${GRUB_CUSTOM_ACPI}" >&2
    prepare_grub_to_access_device `${grub_probe} --target=device ${GRUB_CUSTOM_ACPI}` | sed -e "s/^/  /"
    cat << EOF
acpi (\$root)`make_system_path_relative_to_its_root ${GRUB_CUSTOM_ACPI}`
EOF
fi
</pre>

'''7)''' Set permissions:

<pre>
sudo chown root:root /boot/dsdt.aml
sudo chmod 644 /boot/dsdt.aml
</pre>

'''8)''' Update grub:

<code>update-grub2</code>

Now restart OS and get fully working brightness control. If you've made some errors in step 3 and this prevents OS from correct operation (very unlikely but we'll assume it possible), you can boot from Ubuntu CD, delete <code>/boot/dsdt.aml</code> file, boot to your OS and repeat steps 1-5. Patched <code>dsdt.aml</code> file could be saved somewhere in case of OS reinstall.

 ~+Note+~<<BR>>
 In case of BIOS version upgrade steps 1-5 need to be done again for the new BIOS.
-----
If the brightness of the Internal Display is too dark, then you can manually override it via:

<code>sudo setpci -s 00:02.0 f4.b=FF</code>

The value in the End ranges from 0-255.

==== Screen Brightness Control ====

Several people have reported screen brightness control as non-working with the tm2 in Ubuntu ( https://bugs.launchpad.net/ubuntu/+source/linux/+bug/516772 )

As mentioned above, the brightness of the internal display can be overridden using:
<code>sudo setpci -s 00:02.0 f4.b=FF</code>
However, this is cumbersome to remember and is prone to errorous input data. To address these problems, you could use the following script. Copy the text below and store it in '''/usr/local/bin/setbrightness'''
<pre>
function print_usage() {
  echo "Usage:"
  echo "  sudo setbrightness BRIGHTNESS"
  echo "    where BRIGHTNESS is between 0 and FF"
}
brightness=$1
if <nowiki>[[ $(whoami) != "root" ]]</nowiki>; then
    print_usage
    echo "This script needs to be executed as root."
    exit 1
fi
if [ ! "$#" -eq 1 ]; then
    print_usage
    exit 1
fi
if [ "${#brightness}" -gt 2 ]; then
    print_usage
    exit 1
fi
disallowed_chars=$( echo $brightness | grep -o "[^0-9a-fA-F]*" )
if [ ! -z "$disallowed_chars"]; then
    print_usage
    exit 1
fi

setpci -s 00:02.0 F4.B=$brightness
</pre>

Then make the script executable by running <code>sudo chmod +x /usr/local/bin/setbrightness</code>
You should now be able to set the backlight by running <code>sudo setbrightness <brightness></code>
where <brightness> is a value between 0 (no backlight) and FF (full backlight).

To make the brightness buttons work, you need to create another script that increases or decreases the brightness relative to the current value. Copy the following text to '''/usr/local/bin/brightness-updown'''
<pre>
function print_usage {
  echo "Turn the brightness up or down."
  echo "Usage:"
  echo "  sudo brightness-updown <up/down>"
}

if <nowiki>[[ $(whoami) != "root" ]]</nowiki>; then
    print_usage
    echo "This script needs to be executed as root."
    exit 1
fi
brightness_max=255
brightness_min=15
n_steps=5

step_size=$(( ($brightness_max - $brightness_min) / $n_steps ))
current_brightness=$(( 0x$(setpci -s 00:02.0 F4.B) ))

if <nowiki>[[ "$1" == "up" ]]</nowiki>; then
    if [ $current_brightness -eq $brightness_max ]; then
	exit 0
    fi
    wanted_brightness=$(( $current_brightness + $step_size ))

    if [ $wanted_brightness -gt $brightness_max ]; then
	wanted_brightness=$brightness_max
    fi
    
elif <nowiki>[[ "$1" == "down" ]]</nowiki>; then
    if [ $current_brightness -eq $brightness_min ]; then
	exit 0
    fi

    wanted_brightness=$(( $current_brightness - $step_size ))

    if [ $wanted_brightness -lt $brightness_min ]; then
	wanted_brightness=$brightness_min
    fi

else
    print_usage
    exit 1
fi

wanted_brightness_hex=$(printf "%X" $wanted_brightness)

sudo setbrightness $wanted_brightness_hex
</pre>

Make the script executable <code>sudo chmod +x /usr/local/bin/brightness-updown</code> 
and test it using <code>sudo brightness-updown up/down</code>

To map the script to the brightness keys, execute <code>acpi_listen</code> press the brightness down and up buttons, and note the output. Example output shown below:
<pre>
video LCD 00000087 00000000
video DD03 00000087 00000000
video LCD 00000086 00000000
video DD03 00000086 00000000
</pre>

Then create two files in '''/etc/acpi/events/''' called '''hp_brightness_up''' and '''hp_brightness_down''' as below:

<pre>
event=video DD03 00000086 00000000
action=/usr/local/bin/brightness-updown up
</pre>

and

<pre>
event=video DD03 00000087 00000000
action=/usr/local/bin/brightness-updown down
</pre>

Now restart acpi <code>sudo restart acpid</code> and the brightness keys should work.

==== vga_switcheroo ====
----
Ubuntu Community Documentation has a <nowiki>[[https://help.ubuntu.com/community/HybridGraphics|good article]]</nowiki> about handling hybrid graphics. It is strongly recommended to have a look in case GPU switching is required. In this section you'll find just some the very common information.

From Ubuntu 10.10, the vga_switcheroo kernel module is implemented by default. This module enables switching between graphic cards. It is operated through <code>/sys/kernel/debug/vgaswitcheroo/switch</code> with echo-commands.
Here is a simple script to operate this in a simpler way.

Open your favorite editor f.ex. gedit:

<code>gksudo gedit /usr/local/bin/switch</code>

And paste the following code into the editor:

<pre>
SWITCH=/sys/kernel/debug/vgaswitcheroo/switch
case "$1" in
    low)
        echo "Turning on low-power card."
        sudo sh -c "echo IGD > $SWITCH"
        ;;
    high)
        echo "Turning on high-power card."
        sudo sh -c "echo DIS > $SWITCH"
        ;;
    on)
        echo "Turning on unused card."
        sudo sh -c "echo ON > $SWITCH"
        ;;
    off)
        echo "Turning off unused card."
        sudo sh -c "echo OFF > $SWITCH"
        ;;
    xlow)
        echo "Queuing to use low-power card for next X session."
        sudo sh -c "echo DIGD > $SWITCH"
        ;;
    xhigh)
        echo "Queuing to use high-power card for next X session."
        sudo sh -c "echo DDIS > $SWITCH"
        ;;
    stat)
        cat $SWITCH
        ;;
*** )
        echo "Usage: $SCRIPTNAME {low, high, on, off, xlow, xhigh, stat}"
        echo "    low   - select low-power card"
        echo "    high  - select high-power card"
        echo "    on    - turn on unused card"
        echo "    off   - turn off unused card"
        echo "    xlow  - queue to use low-power card for next X session"
        echo "    xhigh - queue to use high-power card for next X session"
        echo "    stat  - output cards' current status"
        echo
        echo "Status:"
        cat $SWITCH
        ;;
esac
</pre>

Then make it executable using:

<code>sudo chmod +x /usr/local/bin/switch</code>

As you most likely don't want both cards to be powered on at start-up, the following procedure will turn off the unused one at start-up:

To be able to run the script as administrator without providing a password you can add it to the sudoers file. Run:

<code>sudo visudo</code>

And append the following line (exchange $USERNAME with your username):

<code>$USERNAME ALL=NOPASSWD:/usr/local/bin/switch</code>

Now you may add the script to your startup applications. Go to <code>System -> Preference -> Startup Applications</code>, press <code>Add</code> and write <code>gksudo switch off</code> in the Command-field, and for example "Switch off unused graphics card" as the name.

==== Blacklisting GPU driver ====
-----
As integrated GPU powerful enough for most common tasks (including Compiz effects), some users just switch discrete GPU permanently off by blacklisting <code>radeon</code> driver.

 ~+Note+~<<BR>>
 In case of blacklisting <code>radeon</code> driver discrete GPU will still be powered on and battery life won't increase. To power off the GPU use <code>vga_switcheroo</code> mechanism (also, there is possibly another way to switch on/off GPUs: <code>acpi_call</code> module, see <nowiki>[[https://launchpad.net/~hybrid-graphics-linux|hybrid-graphics-linux at Launchpad]]</nowiki>).

Here are the steps. Open file:

<code>gksudo gedit /etc/modprobe.d/blacklist.conf</code>

Add following line to the end of file:

<code>blacklist radeon</code>

Then use following command to update initramfs:

<code>update-initramfs -c -k all</code>

After restart discrete GPU will be permanently disabled.

To enable permanently discrete GPU back: remove blacklisting line you added, update initramfs again and restart.

==== ATI-proprietary driver ====
----
Did not work, and I haven't gotten it to work either. Ubuntu's recovery-option did not work (single), but changing the last part of the boot parameters to init=/bin/bash gave me a way of fixing the error.

=== Touchscreen & Stylus ===
-----
No problems, everything worked out of the box.

To right click using stylus tap the screen, unlike windows you can not hover over the screen to right click.

On the Tm2-2050ca, when you rotate the screen, the stylus's input does not rotate with it. Up is down, and left is right. Need testing if rotation scripts in <nowiki>[[#Screen_rotation|Screen rotation]]</nowiki> section solve the problem.

==== Touchscreen Calibration for Multiple Monitors ====

By default the Touchscreen is mapped to the 'Virtual Desktop', which makes it rather unusable. To avoid that, you have to map the three Devices to the first Display. For example with the following script:

<pre>

@xrandr = `xrandr`;

$xrandr[1] =~ /(\w+)/;

$DISPLAY = $1;

system('xsetwacom --set "Wacom ISDv4 E3 Finger touch" MapToOutput ' . $DISPLAY);
system('xsetwacom --set "Wacom ISDv4 E3 Pen stylus" MapToOutput ' . $DISPLAY);
system('xsetwacom --set "Wacom ISDv4 E3 Pen eraser" MapToOutput ' . $DISPLAY);
</pre>

=== Screen rotation ===

Does not work out of box, but could be implemented using methods in sections below.

==== Rotating the screen ====
-----
Open <code>/usr/local/bin/rotate-display</code> in your favorite editor:

<code>gksudo gedit /usr/local/bin/rotate-display</code>

Paste the following code:

<pre>
touchDev=`xinput --list | grep "Wacom .* touch" | grep -o "id=[0-9]*\W" | grep -o "[0-9]*"`
eraserDev=`xinput --list | grep "Wacom .* eraser" | grep -o "id=[0-9]*\W" | grep -o "[0-9]*"`
stylusDev=`xinput --list | grep "Wacom .* stylus" | grep -o "id=[0-9]*\W" | grep -o "[0-9]*"`

if [ $# != 1 ]; then
    echo 'Usage: '
    echo $0 'none|half|left'
    exit
fi

ROTATE="NONE"
DISP="normal"
if [ "$1" == "half" ]; then
    ROTATE="HALF"
    DISP="inverted"
elif [ "$1" == "left" ]; then
    ROTATE="CW"
    DISP="left"
elif [ "$1" == "right" ]; then
    ROTATE="CCW"
    DISP="right"
fi
echo "Rotating to: $DISP ($ROTATE)"
xsetwacom set $touchDev Rotate $ROTATE
xsetwacom set $eraserDev Rotate $ROTATE
xsetwacom set $stylusDev Rotate $ROTATE

xrandr -o $DISP
</pre>

Make it executable:

<code>gksudo chmod +x /usr/local/bin/rotate-display</code>

You should now be able to rotate the display by running <code>rotate-display $Direction</code> where <code>$Direction</code> is one of: none, half, left, right

==== Automatical rotation ====
-----
To automatically rotate the screen when the screen is flipped, do the following:

If <code>hp_wmi</code> is not loaded, (<code>lsmod | grep hp_wmi</code> returns nothing), add the following to <code>gksudo gedit /etc/modules</code>: <code>hp_wmi</code> (You may also load it for one session with <code>gksudo modprobe hp_wmi</code>)

Then open <code>/usr/local/bin/auto-rotate</code> with for example

<code>gksudo gedit /usr/local/bin/auto-rotate</code>

Paste the following code:

<pre>
old="0"
while true; do
    if [ -e /sys/devices/platform/hp-wmi/tablet ]; then
        new=`cat /sys/devices/platform/hp-wmi/tablet`
        if [ "$new" != "$old" ]; then
            if [ $new == "1" ]; then
                rotate-display half
            elif [ $new == "0" ]; then
                rotate-display none
            fi
            old=$new
        fi
    fi
    sleep 0.5s
done
</pre>

Make it executable

<code>gksudo chmod +x /usr/local/bin/auto-rotate</code>

Now you may add the script to your startup applications. Go to <code>System -> Preference -> Startup Applications</code>, press <code>Add</code> and write <code>auto-rotate</code> in the Command-field, and for example  "Automatically rotate display" as the name.

You may change the direction by changing "rotate-display half" to for example "rotate-display left".

==== Automatical rotation using internal accelerometer ====
-----
Some of the models are fitted with accelerometer in order to park the HDD head in case of extreme acceleration. This accelerometer can be used to rotate the screen, when the computer is tilted enough.
For the purpose, you can see the <nowiki>[[https://sourceforge.net/projects/tm2autorotate/ |tm2-autorotate]]</nowiki> project.

==== Rotating the screen using the rotate button on the side of the screen ====
-----

Save the following script in a file (for example: key-rotate-screen.sh), and give it permissions to be executed, and add it to startup applications: go to <code>System -> Preference -> Startup Applications</code>, press <code>Add</code> and write <code>key-rotate-screen.sh</code> (with full path) in the Command-field, and for example  "Automatically rotate display" as the name.

<pre>
HP_WMI_NAME="HP WMI hotkeys"
KEY_ID="161"
 
primaryScreen=`xrandr | grep primary | cut -d' ' -f1`
touchDev=`xinput --list | grep "Wacom .* touch" | grep -o "id=[0-9]*\W" | grep -o "[0-9]*"`
eraserDev=`xinput --list | grep "Wacom .* eraser" | grep -o "id=[0-9]*\W" | grep -o "[0-9]*"`
stylusDev=`xinput --list | grep "Wacom .* stylus" | grep -o "id=[0-9]*\W" | grep -o "[0-9]*"`
 
function rotate_display() {
	ROTATE="NONE"
	DISP="normal"
	VGADISP="normal"
	if [ "$1" == "half" ]; then
	    ROTATE="HALF"
	    DISP="inverted"
	    VGADISP="normal"
	elif [ "$1" == "left" ]; then
	    ROTATE="CCW"
	    DISP="left"
	elif [ "$1" == "right" ]; then
	    ROTATE="CW"
	    DISP="right"
	fi
	xsetwacom set "$touchDev" Rotate $ROTATE
	xsetwacom set "$eraserDev" Rotate $ROTATE
	xsetwacom set "$stylusDev" Rotate $ROTATE
	xrandr -o $DISP
}
 
trap "kill 0" SIGINT
 
exec 3< <(stdbuf -o0 xinput test "$HP_WMI_NAME")
 
while read <&3 data; do
	if echo $data | grep "$KEY_ID" | grep "release" >/dev/null; then
		currentRotation=$(xrandr -q -v | grep "$primaryScreen" | cut -d ' ' -f 5 | grep -v '(')
		nextRotation=""
		if [ -z "$currentRotation" ]; then
			nextRotation="right"
		elif [ "$currentRotation" == "right" ]; then
			nextRotation="half"
		elif [ "$currentRotation" == "inverted" ]; then
			nextRotation="left"
		else
			nextRotation="none"
		fi
		rotate_display $nextRotation
	fi
done
</pre>

=== Finger print ===
-----
Works nice with libpam-thinkfinger read ThinkFinger for more information

=== Keyboard ===
-----
==== Function Keys ====
----
The HP !TouchSmart tm2 have the function keys and the "special keys" like turning brightness up and down switched in comparison to many other laptops. This means to close a window with [Alt]+[F4], you have to press [Fn] as well. This can be switched back in the BIOS (press [esc] at start-up to access the BIOS).

==== Page Up/Down, Home and End ====
----
No matter how much you search the keyboard you will never find the Page up/down, home or end-buttons. However, these are accessed using [Fn]+[Arrow Key].

=== Touchpad ===
-----
Right button does not work. Strange errors when pressing two buttons at the same time.

To right click tap the bottom right corner.

Starting from Ubuntu 11.04 pressing two fingers on the touchpad to right click or tap on the bottom right corner to right click.

=== Wireless ===
-----
The wireless works out of the box (tm2-2050er / Ubuntu 11.10), no proprietary drivers required.

An easy way to install the Broadcom proprietary driver using Ubuntu 11.10 is to plug the laptop to a wired network and install the driver from System Settings -> Additional Drivers.

* On the Tm2-2050ca, the wireless BCM4313 worked out of the box for me on a fresh installation of PinguyOS (ubuntu 10.10).

=== HDMI ===
-----
Reported errors with HDMI (not working), not confirmed.

On the Tm2-2050ca/tm2-2050e HDMI output for video and sound works perfectly after changing the outputs in Sound Preferences.

----
CategoryHardware
