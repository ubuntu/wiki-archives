{|
  | '''Warning'''
  * This is a '''readonly''' and '''text-based''' archive of a deprecated wiki.
  * '''Images''' and '''attachments''' have been removed to conserve space.
  * '''Links''' may not work and there may be formatting issues.
  * A '''compressed''' version with images and the original syntax is in the repo '''Releases'''.
|}

__TOC__


* '''Launchpad Entry''': UbuntuSpec:hardware-arm-n-irregular-input-device-handler
* '''Created''': 2010-10-22
* '''Contributors''': Emmet Hikory
* '''Packages affected''': gizmod, udev, ?

=== Summary ===

Many armel devices come in interesting form factors, and may have a number of additional hardware buttons (commonly at least send/end), electrostatic panels, etc. Integration of an input multiplexor providing for default remapping of many of these input devices would significantly improve the perception of suitability for Ubuntu on various devices.

=== Release Note ===

Ubuntu now provides an interface to configure all the extra knobs, buttons, and switches available for your hardware.

=== Rationale ===

Lots of devices have "function" buttons, "Send/End" keys, slidewheels, maximize buttons, switch buttons, and other sorts of things not built into the standard laptop.  These ought be mapped somehow, and made available for useful functions to the user.

=== User stories ===

* Alice installs Ubuntu on her phone.  She wants the nearby-group-chat button to bring up her contact list in empathy.
* Bob installs Ubuntu on his handheld.  He wants the lock-screen switch to lock the screen.
* Chris installs Ubuntu on a set top box, and needs the remote control to work.
* Dora's netbook has an electrostatic function bar, and she wants it to launch her favorite applications.

=== Assumptions ===

* Every function button or similar ends up being some sort of /dev/input/ device.

=== Design ===

Needs discussion: do we want to hardcode everything we can think of into a specific keysym, and then map keysyms to functions?  Do we want to provide the user with a configuration tool where they press some random key, and tell us what it does?  How do we handle mapping for new devices?

=== Implementation ===

TBD

==== UI Changes ====

TBD

==== Code Changes ====

TBD

==== Migration ====

No migration is expected: users with complex custom udev rules or rich gizmod scripts can probably deal with the changes that come with a release, and the rest of the users will just notice that things now work.

=== Test/Demo Plan ===

* Demo Ubuntu running on a Phone.  Adjusting the hook switch should do something interesting (or at least generate a programmable event).

=== Unresolved issues ===

* Detailed UI implementations (let's figure out *how* to do it, and UI can be per-flavour later)
* Specific Device Support (let's make something generic, and then add devices to the framework)

=== BoF agenda and discussion ===

==== Data Collection ====

* What potential buttons are there?
* Which ones aren't defined in standard key lists?
* How do we handle knobs and switches?
* How can we collect significant volumes of data on common input arrangements?

==== Design Solutions ====
* udev hinting
* gizmod scripts
* lircd
* interfacing with existing keyboard shortcut tools
* other implementation ideas

==== Plans for PoC ====
* Which solution is best (or best two)?
* Who has testable devices?
* Who will prepare test scripts?
* When can we determine if we can land something coherent for natty (compelling comes later).

----
CategorySpec
