{|
| '''Warning'''
* This is a '''readonly''' and '''text-based''' archive of a deprecated wiki.
* '''Images''' and '''attachments''' have been removed to conserve space.
* '''Links''' may not work and there may be formatting issues.
* A '''compressed''' version with images and the original syntax is in the repo '''Releases'''.
|}

__TOC__

This page is to develop and test useful abstractions. 

These will define our 'conceptual modeling language' and can be used to describe various scenarios with use cases as well as drive the implementation.

This is worthwhile as we want to work with a number of input devices, selection mechanisms and interactions with applications.

<nowiki>[[http://ace-centre.hostinguk.com/assets/Product%20Downloads/SwitchScanningMaster_8_472.pdf|Switch Scanning]]</nowiki> provides an introduction to scanning and attempts to define a nomenculture.

The above document is pretty comprehensive where switch access is concerned, but only brushes the topic of "valuator" or "pointer" access (i.e. non-binary input devices such as head pointers, eye-gaze, trackballs, etc.)  I suggest we use the term ''valuator'' to refer to such a device, and ''axes'' to refer to the scalar input channels from such devices.  For instance, a typical mouse device would provide a valuator input with two axes (it would also provide up to 5 switches; note that the apparent "valuator" input which is provided by a scrollwheel on a mouse is actually implemented as buttons 4 and 5, thus a scrollwheel mouse is technically a 2-axis valuator plus a 5-button switch input).

One other minor gap in the above switch access document is the absence of a good term for the "subset selection" process - it uses the term "highlighting" to refer to the user-indication that a particular ''subset'' of a ''selection set'' is active.  GOK documentation and GUI refers to this as ''selection'', and uses the term ''activation'' to refer to the final end-user-driven choice of one item from within the selection set, whereas the switch document refers to this latter operation as ''selection''.  I don't mind if we use ''highlighting'' here, as long as it is understood that the actual mechanism for presenting the user with the active ''subset'' of the ''selection set'' may be something other that graphical.

=== Basic Modules ===

OSK/alternative input access (should we coin a new term for this, rather than keep saying OSK?) can be reasonably divided into three major aspects or modules:

* input
** device interface
** abstractions of ''switch'' and ''valuator''
** timing/debounce/filtering etc.
* logic
** maintains state and possibly makes decisions based on the user's 
     previous interactions, e.g. for word completion
**** may include keyboard 'stacks' and 'branching' within hierarchy
** receives and interprets events from the running desktop session,
     to determine the user's current application context
**** for instance, when a menu is posted, OSK may choose to replace the current
        ''selection set'' with the menu items
** interacts with the user's application context
* presentation
** shows the user the current selection set
** gives the user feedback about the OSK state, provides ''highlighting'', etc.
*** provides info on when selection has occurred,  timing status, ''branchback'', etc.
** displays in a way appropriate to the user's desktop session GUI
*** for emulating a physical keyboard, may render a realistic qwerty kbd, etc.
*** ensures that selection set remains unobscured, via docking, stay-on-top behavior, etc.
*** may include speech output, audio cues, in-place scanning, etc.
