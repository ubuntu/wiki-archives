{|
| '''Warning'''
* This is a '''readonly''' and '''text-based''' archive of a deprecated wiki.
* '''Images''' and '''attachments''' have been removed to conserve space.
* '''Links''' may not work.
* A '''full compressed version''' of the wiki is available on archive.org
|}

__TOC__

As explained in the Design document, a TestSuite in the Mago framework contains two different files, a .py file with the TestSuite class and methods and a .xml file, with the description of the TestSuite.

When writing a new TestSuite with the Mago framework, based on already available applications in the library, create the .py file and the .xml based on the following templates (<nowiki>[[available classes]]</nowiki>):

==== Python File ====

{{{#!python
import ldtp
import ldtputils

from mago.testsuite.main import TestSuite
from mago.application.ubuntu import <BaseClass>
from mago.application.gnome import <BaseClass>

class <SuiteClass>(TestSuite):

    def setup(self):
##### setup code, put here what happens at
##### the beginning of the testsuite

    def teardown(self):
##### teardown code, put here what happens when
##### the testsuite finishes

    def cleanup(self):
##### Add here what happens between test cases,
##### i.e. cleaning logs and/or temp files

    def <method1>(self, arg1, arg2):

        self.do_stuff()
        self.do_stuff()
        
        if do_some_check() == FAIL:
            raise AssertionError, "Human readable message"

if __name__ == "__main__":
    <example_test> = <SuiteClass>()
    <example_test>.run()
}}}

The python file contains the code for the test script. We are going through the script lines, explaining each of them.

* 1,2: Needed only when calling ldtp functions directly in the script.
* 5: TestSuite is the base class for a new test suite
* 11: SuiteClass is the name of the class for the giving suite. Anyname would do, but a descriptive name is better.
* 11: In general, test suites will inherit from TestSuite class
* 13: The setup method will be called at the beggining of a test suite, but not between test cases within the same suite. 
* 17: The teardown method will be called at the end of a complete test suite, but not between test cases within the same suite.
* 21: The cleanup method will be called at the end of each test case. Write code that cleans up the mess introduced by a test case that could interfere with the next one.
* 25: method1. A suite can contain as many methods as needed. This is were the script code is written.
* 27,28: call any methods in the BaseClass to perform the script actions
* 30: Do some check after the script to assert that it passed. Raise an AssertionError if something failed.
       You can also return a list on success (message, screenshot), that will log a message and will grab a screenshot. message will be a string, screenshot, the path of screenshot file.
* 33: The main class just creates an instance of the SuiteClass and calls the run method. The TestSuite runner will do the rest.

===== Single Application Test Suite =====

One common use case is having a test suite that only test one application. For those cases the setup, teardown and cleanup methods normally contain common code (i.e. setup, opens the application, teardown closes the application, etc.).

For those cases, the test suite can be inherited from one of the SingleApplication test suites, that already implement those methods.

For example, to create a test suite that only test Gedit, the python template above can be changed for:

{{{#!python
import ldtp
import ldtputils

from mago.test_suite.gnome import GEditTestSuite

class <SuiteClass>(GEditTestSuite):

    def <method1>(self, arg1, arg2):

        self.do_stuff()
        self.do_stuff()
        
        if do_some_check() == FAIL:
            raise AssertionError, "Human readable message"

if __name__ == "__main__":
    <example_test> = <SuiteClass>()
    <example_test>.run()
}}}

In this case, the setup, teardown and cleanup methods are implemented in the GEditTestSuite class.

==== XML File ====

<pre>
<?xml version="1.0"?>
<suite name="A name for your suite">
 <class>{module_name}.{SuiteClass}</class>
  <description>
    A nice description about the purporse of the test suite
  </description>
  <!-- args of the suite main class -->
  <args>
      <arg1>contentofarg1</arg1>
      <arg2>contentofarg2</arg2>
      ...
      <argN>contentofargN</argN>
  </args>
  <case name="{NameCase1}">
    <method>{methodcase1}</method>
    <description>A description of the first testcase</description>
    <!-- args of the case method -->
    <args>
      <arg1>contentofarg1</arg1>
      <arg2>contentofarg2</arg2>
      ...
      <argN>contentofargN</argN>
    </args>
  </case>
  <case name="{NameCase2}">
    <method>{methodcase2(couldbethesameas1)}</method>
    <description>A description of the second testcase</description>
    <args>
      <arg1>contentofarg1</arg1>
      <arg2>contentofarg2</arg2>
      ...
      <argN>contentofargN</argN>
    </args>
  </case>
</suite>
</pre>

The XML file is almost self-describing. The most important parts of it are explained below:

* The suite root node has a name attribute, with the name of the suite.
* The <class> tag contains the module name of the .py file and the SuiteClass class (same as the one in the .py file)
* The <description> tag contains a human readable description of the purpose of the suite.
* The test suites can have 0 or more arguments (they will be passed to the constructor)
* For each case in the suite we will add a case child node with the following content:
** A name attribute with the name of the case
** The <method> tag contains the name of the method of the SuiteClass to run for that particular test case.
** The <description> tag describes the test case in a human readable manner.
** Add a new child tag to the <args> tag with the argument name of the test case method. 
   i.e. if the method signature is something like:
   {{{
   def my_method(self, name, surname):
   }}}
   then, the <args> node of the XML file will contain something like:
   {{{
   <args>
     <name>John</name>
     <surname>Smith</surname>
   </args>
   }}}
   That allow us to use the same method for different test cases. 
