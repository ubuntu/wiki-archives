{|
| '''Warning'''
* This is a '''readonly''' and '''text-based''' archive of a deprecated wiki.
* '''Images''' and '''attachments''' have been removed to conserve space.
* '''Links''' may not work.
* A '''full compressed version''' of the wiki is available on archive.org
|}

__TOC__



=== Launcher API ===

We support adding quicklists, counters, and progress bars for apps in the Unity Launcher:

<nowiki>[[File:unityapi.png]]</nowiki>

<nowiki>[[File:quicklilst-static-entry.png]]</nowiki>

=== Using the Launcher API ===

The recommended and supported way to take control of your launcher icon is to use the API provided by '''libunity'''. This library wraps a low level DBus protocol which is documented below.

Each launcher icon can be controlled remotely by a discrete <code>LauncherEntry</code> object. New launcher entry object may be created by call `unity_launcher_entry_get_for_desktop_id (char *id);` where id is the name of the desktop file shipped by the application you wish to control. For example evolution ships <code>"evolution.desktop"</code> or empathy ships <code>"empathy.desktop"</code>.

<code>LauncherEntry</code>es are able to control 4 major components of a Launcher Icon: 

==== Count ====

The first aspect they can control is the count associated with the icon. The count may be set by calling 
<pre>
unity_launcher_entry_set_count (UnityLauncherEntry *self, gint64 count);
</pre>

This will remotely prime the count, then calling 
<pre>
unity_launcher_entry_set_count_visible (UnityLauncherEntry *self, gboolean visible)
</pre> 
can toggle its visible status. Updates to the count and other properties are live, unsetting and resetting the visibility is not require nor is it encouraged.

==== Progress ====

progress can be set by 
<pre>
unity_launcher_entry_set_progress (UnityLauncherEntry *self, gdouble progress)
</pre>
and made visible by calling
<pre>
unity_launcher_entry_set_progress_visible (UnityLauncherEntry *self, gboolean visible);
</pre>

The <code>progress</code> value should be between <code>0.0</code> and <code>1.0</code>.

==== Urgency ====

You can set an urgency of your launcher icon by setting a boolean on the <code>urgent</code> property:
<pre>
unity_launcher_entry_set_urgent (UnityLauncherEntry *self, gboolean urgent);
</pre>

==== Quicklists ====

There are two kinds of Quicklists: the static ones which are always shown once on right-click from the launcher entry and dynamic ones which are only displayed once the application is started.

===== Static Quicklist entries =====

Adding a Static Quicklist entry is very easy, all you need is to add some support to the desktop file. This is based on the desktop file formats <nowiki>[[http://standards.freedesktop.org/desktop-entry-spec/latest/ar01s08.html | Action Groups]]</nowiki>.

Here is what needs to be added to gnome-screenshot to support Quicklist
<pre>
 [â€¦]
 Actions=Screen;Window;

[Desktop Action Screen]
Name=Take a Screenshot of the Whole Screen
Exec=gnome-screenshot
OnlyShowIn=Unity;

[Desktop Action Window]
Name=Take a Screenshot of the Current Window
Exec=gnome-screenshot -w
OnlyShowIn=Unity;
</pre>

'''Actions''' is referencing a ''Desktop Action''. Each ''Desktop Action'' references an item entry in the Quicklist. Here, we have the "Screen" and "Window" entries, corresponding to :

[Desktop Action '''entry''']

Then, each group have:
* a Name=, which is the entry as it's displayed which should be in <nowiki>[[http://en.wikipedia.org/wiki/Title_case#Headings_and_publication_titles | title case]]</nowiki>.
* an Exec= referring a command line to execute once clicked.  <nowiki>[[http://standards.freedesktop.org/desktop-entry-spec/latest/ar01s06.html | Details on additional syntax]]</nowiki>.
* Only``Show``In=Unity is recommended to tell "show that entry in the Unity Springboard Quicklist" so that the file can be given upstream without the possibility of showing up in other untested desktop environments.  Please let upstream projects decide if they want to have this action shown more widely.
* Optional ``Path=`` key can be used to define the working dir used to launch the exec.

In the desktop spec there is a full <nowiki>[[http://standards.freedesktop.org/desktop-entry-spec/latest/apa.html | desktop file sample with actions.]]</nowiki>  Here is an <nowiki>[[attachment:02_add_unity_quicklist_support.patch|example of a patch for gnome-utils]]</nowiki> using the old X-Ayatana style, but shows how to format the patch, with links to ubuntu bug and forwarded upstream.

===== Dynamic Quicklist entries =====

Quicklists may also be created and appended to the launcher. To create a quicklist a root node must first be created as a container, and then child nodes are added to it. This final result may be packed into the launcher which is then shipped over the bus to Unity. Updates to the quicklist are also live. Rather than describe the entire API, an example of using quicklist (as well as progress and count) is provided below using the vala bindings.

It is important to note that the main loop must be invoked for the program to actual work. Libunity requires the usage of the main loop as work may be done async.

===== Quicklist elements =====

Quicklists can contain:
* Textual links
* Text with no associated action
* Select options
* Radio options
* Horizontal dividers 

See <nowiki>[[https://bugs.launchpad.net/unity/+bug/767063/+attachment/2162595/+files/quicklist.png|visual design]]</nowiki> to view examples of all these elements in context.

=== Filing Bugs ===

* https://launchpad.net/libunity
* If you're having a problem with the launcher not displaying or incrementing, then it's probably a libunity problem. If the rendering is wrong, it's probably a unity bug and not libunity.
* <nowiki>[[http://unity.ubuntu.com/contact-us/|Contact Us]]</nowiki>

=== Example Code ===

==== Vala Example ====

<pre>
/* Compile with: valac --pkg unity launcherexample.vala */
namespace LauncherExample {

  public static void main ()
  {
    /* Pretend to be evolution for the sake of the example */
    var l = Unity.LauncherEntry.get_for_desktop_id ("evolution.desktop");

    /* Show a count of 124 on the icon */
    l.count = 124;
    l.count_visible = true;

    /* Set progress to 42% done */
    l.progress = 0.42;
    l.progress_visible = true;
    
    /* We also want a quicklist */
    var ql = new Dbusmenu.Menuitem ();
    var item1 = new Dbusmenu.Menuitem ();
    item1.property_set (Dbusmenu.MENUITEM_PROP_LABEL, "Item 1");
    var item2 = new Dbusmenu.Menuitem ();
    item2.property_set (Dbusmenu.MENUITEM_PROP_LABEL, "Item 2");
    ql.child_append (item1);
    ql.child_append (item2);
    l.quicklist = ql;

    new MainLoop().run();
  }
  
}
</pre>

==== Python Example ====
<pre>

from gi.repository import Unity, Gio, GObject, Dbusmenu

loop = GObject.MainLoop()

launcher = Unity.LauncherEntry.get_for_desktop_id ("evolution.desktop")

launcher.set_property("count", 124)
launcher.set_property("count_visible", False)

launcher.set_property("progress", 0.42)
launcher.set_property("progress_visible", True)

ql = Dbusmenu.Menuitem.new ()
item1 = Dbusmenu.Menuitem.new ()
item1.property_set (Dbusmenu.MENUITEM_PROP_LABEL, "Item 1")
item1.property_set_bool (Dbusmenu.MENUITEM_PROP_VISIBLE, True)
item2 = Dbusmenu.Menuitem.new ()
item2.property_set (Dbusmenu.MENUITEM_PROP_LABEL, "Item 2")
item2.property_set_bool (Dbusmenu.MENUITEM_PROP_VISIBLE, True)
ql.child_append (item1)
ql.child_append (item2)
launcher.set_property("quicklist", ql)

def update_urgency():
    if launcher.get_property("urgent"):
        print "Removing urgent flag"
        launcher.set_property("urgent", False)
    else:
        print "setting urgent flag"
        launcher.set_property("urgent", True)
    return True

GObject.timeout_add_seconds(5, update_urgency)

loop.run()

</pre>
=== Low level DBus API: com.canonical.Unity.LauncherEntry ===

{| class="wikitable"
|-
| <#ffeeee> (!) '''While the libunity API is stable, the DBus protocol underneath is not. We strongly discourage anyone from relying on it'''
|}

Application authors normally should not need to care about the raw DBus API. <code>libunity</code> implements all of this in a nice and convenient API.

This API is designed to minimize the number of DBus messages needed in order to set up the launcher icons, and generally cater for devices with less-than-desktop processing powers. Unity ships not only on netbooks but also on several 3rd party tablet setups. This demands special attention to CPU hungriness, power consumption, and IO.

 <code>signal</code> '''com.canonical.Unity.!LauncherEntry.Update (<code>in s app_uri, in a{sv} properties</code>)'''

This signal is emitted by an application whenever it wishes to change state of any of its launcher properties. It's important to emphasise that the signal ''only includes the properties that have changed''. This ensures that the protocol is extensible without changing libunity.

Unity will pick up the <code>Update</code> signal by having a DBus match rule catching all signals from <code>com.canonical.Unity.LauncherEntry</code> disregarding its origin. It's the responsibility of the emitting party to <code>Update</code> with all know state when the name <code>com.canonical.Unity</code> becomes owned on the bus. Otherwise there may be synchronization issues on boot up or if the Unity shell is restarted for some reason.

 . '''app_uri''' : A URI on the form <code>application://$desktop_file_id</code>. The desktop file id of an application is defined to be the basename of the application's <code>.desktop</code>-file including the extension. So taking Firefox as an example it would be <code>application://firefox.desktop</code>

 . '''properties''' : A map of strings to variants with the properties to set on the launcher icon. Valid properties are:
  . <code>"count"</code> (type signature <code>x</code>): A number to display on the launcher icon. You must also set the <code>"count-visible"</code> property to <code>true</code> in order for this to show.
  . <code>"progress"</code> (type signature <code>d</code>) : A double precision floating point number between 0 and 1. This will be rendered as a progress bar or similar on the launcher icon. You must also set the <code>"progress-visible"</code> property to <code>true</code> in order for this to show.
  . <code>"urgent"</code> (type signature <code>b</code>) : Tells the launcher to get the users attention
  . <code>"quicklist"</code> (type signature <code>s</code>) : The object path to a <code>DbusmenuServer</code> instance on the emitting process. An empty string denotes that the quicklist has been unset. This also explains why we use signature <code>s</code> and not <code>o</code>. The empty string is not a valid object path.
  . <code>"count-visible"</code> (type signature <code>b</code>) : Determines whether the <code>"count"</code> is visible
  . <code>"progress-visible"</code> (type signature <code>b</code>) : Determines whether the <code>"progress"</code> is visible
  . <code>"updating"</code> (type signature <code>b</code>) : Tells the launcher that the application is being updated, to inform the user.

Mainly for debugging purposes applications using the <code>Update()</code> signal must also expose a <code>Query</code> method on the same object path as they emitted the <code>Update</code> signal from:

 <code>method</code> '''com.canonical.Unity.!LauncherEntry.Query (<code>out s app_uri, out a{sv} properties</code>)'''

The return values match exactly the paramters described in the <code>Update</code> signal.

=== FAQ ===

* ''Why not use the <code>org.freedesktop.DBus.Properties</code> interface instead?''
 . Good question! The standard properties interface of DBus is designed in a polling fashion, and would require Unity to query a well known address for the properties, which in turn demands that we use some sort of registration mechanism. The beauty of the custom API is that it flips the roles, it's a pushing mechanism instead of a pulling mechanism. This makes the registration step implicit and book keeping easier. Not to mention requiring fewer DBus roundtrips.

* ''Why not use the de-facto standard <nowiki>[[http://wiki.go-docky.com/index.php?title=Writing_Helpers#DockManager_DBus_Interface_Specification|DockMangaer API]]</nowiki> instead?''
 . Good question again! The introductory paragraph on the DBus API section gives the clue here. The !DockManager API is great for a desktop dock. But if you analyze it you'll see that it requires a great many DBus messages exchanged when exercised fully. Thus not a great choice for devices with less-than-desktop powers.
 . The !DockManager interface also doesn't interface with the <nowiki>[[http://people.canonical.com/~agateau/dbusmenu/spec/classorg_1_1ayatana_1_1dbusmenu.html|Dbusmenu protocol]]</nowiki> which is more expressive than the !DockManager counterpart. There are also both technical- and UI choices in the !DockManager API that doesn't fit well with the vision for Unity.
 . Summing up; if we had gone with the !DockManager interface it would have been an strict subset with a suite of custom non-compatible extensions. Some companies does not flinch from calling this behaviour "standard compliance", but let's be honest with our selves. It's no longer the !DockManager interface we'd be supporting, but a custom one.
----
CategoryDesktopTeam
