{|
| '''Warning'''
* This is a '''readonly''' and '''text-based''' archive of a deprecated wiki.
* '''Images''' and '''attachments''' have been removed to conserve space.
* '''Links''' may not work.
* A '''full compressed version''' of the wiki is available on archive.org
|}

__TOC__


=== Test Environment ===

* one (test) server running locally.
* three syncdaemons (SD1, SD2 and SD3) running locally with separated home and root directories, and separated log files. SD1 and SD2 run against the same user, SD3 uses a second user.

=== Test descriptions ===

{| class="wikitable"
|-
| #
| Description
| Passes?
|-
| 0
| Create two UDFs such as suggested path collide. Assert that both UDFs can be created.
| INVALID. Suggested path can not collide.
|-
| 1
| SD1 creates an UDF with files in it. Assert that SD2 receives the notification of the new UDF. Assert that every file is downloaded and created in SD2's UDF.
| OK
|-
| 2
| SD1 creates two UDFs. Assert that SD2 receives the correct list of UDFs when querying the list of volumes.
| OK
|-
| 3
| SD1 creates an UDF, SD2 already has the same UDF, SD1 unsubscribes from it. Assert that SD2 still is subscribed to the UDF.
| OK
|-
| 4
| SD1 creates an UDF, SD2 already has the directory (but is not an UDF yet, and there is no overlap between directories and files). Assert that SD2 merges correctly the directory when it's notified of the UDF.
| OK
|-
| 5
| SD1 creates an UDF, SD2 already has the directory (but is not an UDF yet, and there is directory and file overlapping). Assert that SD2 merges correctly the directory when it's notified of the UDF existance.
| OK
|-
| 6
| SD1 creates an UDF, SD2 already has the same UDF, SD1 renames any of the UDF ancestors. Assert that SD1 is unsubscribed from the UDF and that SD2 still has the UDF (no deletion).
| OK
|-
| 7
| SD1 creates an UDF, SD2 already has the same UDF, SD1 renames the UDF itself. Assert that SD1 is unsubscribed from the UDF and that SD2 still has the UDF (no deletion).
| OK
|-
| 8
| SD1 creates an UDF, SD2 already has the same UDF, SD1 removes recursively the UDF. Assert that the UDF is deleted on server and that SD2 receives the VM_VOLUME_DELETED. Assert that inner files within the UDF are deleted as well.
| OK
|-
| 9
| An UDF can not be created within the user's root-root. SD1 attempts to create an UDF in the user's root. Assert that SD1 receives a NO PERMISSION.
| OK
|-
| 10
| An UDF can not be created within another UDF. SD1 attempts to create an UDF in an existent UDF. Assert SD1 receives a NO PERMISSION.
| OK
|-
| 11
| Capabilities test: SD1 has the VOLUME capability and SD2 hasn't. Assert SD2 doesn't crash.
| Setup for this test is extremely complicated, we should evaluate to do it "by hand".
|-
| 12
| Share a file or a folder within an UDF to another user. Make a test for a RO Share, and one for a RW Share. Check that the Shares are returned in get_shares() for the receiving user.
| OK
|-
| 13
| Create an UDF, disconnect the SD, do stuff with the folder in the file system, and then reconnect.
| OK
|-
| 14
| Unsubscribe an UDF, remove every file in file system for that UDF, re-subscribe it.
| OK
|-
| 15
| SD1 and SD2 already have the same UDF, SD1 unsubscribes from it. Assert that SD1 can re-subscribe to and UDF.
| OK
|-
| 16
| Create two UDFs on SD1 having an ancestor in common and wait for SD2 to replicate them. Rename the common ancestor. Assert that SD1 is unsubscribed from both UDFs.
| OK
|-
| 17
| Create an UDF, rename one ancestor so the UDF gets unsubscribed, and watches are removed for them. Assert no events for any ancestor is received, except if the ancestor is also ancestor for another UDF.
| OK
|-
| 18
| Share the folder of an UDF itself. The other user should see the content ok.
| OK
|-
| 19
| Create and UDF, put there a complex structure with some dirs and files in disk. Unsubscribe from the UDF. Remove and add some files. Subscribe to the UDF again. Assert that new files are uploaded to server, and deleted files are brought back.
| OK
|}
