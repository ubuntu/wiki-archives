{|
| '''Warning'''
* This is a '''readonly''' and '''text-based''' archive of a deprecated wiki.
* '''Images''' and '''attachments''' have been removed to conserve space.
* '''Links''' may not work and there may be formatting issues.
* A '''compressed''' version with images and the original syntax is in the repo '''Releases'''.
|}

__TOC__

== UATH Compatible Test Cases ==

Any binary that can run on Ubuntu, can be considered a Test Case as far as UAT is concerned. If you add the right control files and structure your test suite in directories neatly, UAT will run whatever you want. This is both good and bad, because it means we are counting on self-discipline to develop new test cases to a good standard, even if legacy test cases are not as good as they could be. 

=== Directory Structure ===
This is what a UATH test suite looks like:

<pre>
.
├── category
│   ├── testsuite1
│   │   ├── t1
│   │   │   ├── Makefile
│   │   │   ├── t1.c
│   │   │   └── tc_control
│   │   ├── t2
│   │   │   ├── test.py
│   │   │   └── tc_control
│   │   ├── ts_control
│   │   └── tslist.run
│   └── testsuite2
├── category2
└── master.run

</pre>

=== Runlists Hierarchy ===

A runlist is a collection of test cases that we want to run in one go. The syntax for runlists is:

'''master.run file contains:'''

<pre>
- name: testsuite1 (or security/testsuite2)
  fetch_cmd : git clone/pull wherever
    include_tests:
    - t1
    - t2
    - t3...
  runlist: amd64.   # this runlist overrides the
########### default one

- name: security/testsuite2
  exclude_tests:
    - st4
    - st5
</pre>

Test suites can be divided in categories (for our internal use, or for test cases submitted to our test case base) or they can be in a repository anywhere.

Each test suite has a default runlist and a control file that contain as follows:

'''tslist.run file contains:'''

<pre>
- test: t1                             # directory
  command: python test1.py a1 a2 a3    # command to run the test from within t1
  run_as: nobody                       # user that runs the test

- test: t2                             # directory/binary
  command: test2.sh
  overrides:                           # array of control properties to override
  - timeout: 200                       # timeout in seconds
</pre>

'''ts_control file contains:'''

<pre>
build_cmd:      make
timeout:        300
ts_setup:       tsetup/setup.sh      # test case t1 is the set up for
################### the whole test suite
ts_cleanup:     tcleanup/cleanup.sh  # clean up test case
</pre>

To avoid excessive typing and repetition in runlists and control files the following rules apply:
* <code>tslist.run</code>'s '''test''' is relative to the test suite.  So if the suite is called ''sample_tests'' and the entry in <code>tslist.run</code> for test is ''test_one'' then the path to the test folder will be sample_tests/test_one.
* <code>tslist.run</code>'s '''command''' is relative to the testcase’s folder.  So the above test with a '''command''' of <code>python test_one.py</code> will result in this effectively: 
<pre>
      cd sample_tests/test_one && python test_one.py
</pre>
* <code>ts_control</code> is optional.
* if <code>build_cmd</code>, or <code>ts_setup</code> fails no tests in the suite will be run.
* if <code>build_cmd</code>, or <code>tc_setup</code> fails the test will not be run.
* <code>ts_cleanup</code> will be run whether or not ts_setup, build_cmd, or any tests fail.
* <code>tc_cleanup</code> will be run whether or not tc_setup, build_cmd, or the tesjk fail.

Each test case, with all the code required for it to compile or run, lives in a folder, and contains also a control file that '''includes its documentation''' amongst other things:

'''tc_control file contains:'''
<pre>
build_cmd:      make    # or scons or build.sh
description:
( tc_id: TC-INSTALL-ALTERNATE-01)
 dependencies:
 actions: |
1. Action 1
2. Action 2
 expected_results: |
1. Expected result 1
2. Expected result 2
type:           build_only/userland/kernel (?)
timeout:        100
tc_setup:   	t1/t1 setup    # in case the test case has a setup
tc_cleanup: 	t1/t1 cleanup  # in case the test has a cleanup
</pre>

For each test case that is a binary or a script, we will give them the option to define a setup and a cleanup function if they wish so, and it is the test code developer’s responsibility to add the right parameters to their code so that the harness can run their setup and clean up functions.

'''In terms of settings precedence:'''
The test suite control file provides a default value for all the test cases in the test suite. Each test case can override those settings in its own control file.  The overrides in the suite level runlist override both of them (the idea behind being to be able to set up different timeouts depending on the architecture the tests ought to be run on, if necessary).
