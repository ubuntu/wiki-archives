{|
| '''Warning'''
* This is a '''readonly''' and '''text-based''' archive of a deprecated wiki.
* '''Images''' and '''attachments''' have been removed to conserve space.
* '''Links''' may not work and there may be formatting issues.
* A '''compressed''' version with images and the original syntax is in the repo '''Releases'''.
|}

__TOC__

<pre>
__          __  _____   _____  
\ \        / / |_   _| |  __ \ 
 \ \  /\  / /    | |   | |__) |
  \ \/  \/ /     | |   |  ___/ 
   \  /\  /     _| |_  | |     
    \/  \/     |_____| |_|     
                               
</pre>

=== Introduction ===
While packaging an application you will discover that debian/rules file is one of the most importants maintainer scripts required for a perfect package's build. This file it's simply a makefile, and learning make structures, variables and constructions can help you to understand how to modify and learn maintainer scripts like debian/rules too. Rules file can be invoked by saying its name instead of launching make itself, thanks to the starting line at the top of the file: #!/usr/bin/make -f.

A simple rule is made on a simple structure based on targets, dependencies and commands. Here is what a simple rule looks like:

<pre>
config.status: bar 
foo

Add here commands to configure the package.
./configure 
</pre>

In our case:

# <code>target</code> is "config.status"
# <code>dependencies</code> are represented by "bar"
# <code>foo</code> and <code>./configure</code> are the commands that will be executed, in this case, to configure the package.
The lines with the colon " : " in them are called dependency lines. They determine whether the target has to be rebuilt. The Left side of the colon is identified as the target itself of the dependency. Right side of the colon got the sources needed to make the target. A dependency line says, for example, that the target depends on a source file or a to another target as in the previous example. Until configure target is launched, config.status is not able to work as it depends directly from configure target specified above. When this has been verified, rules file keep checking the next space under this target where the developer will place every command is needed to build/configure/clean the package.

The Makefile rules for building and installation can also use compilers and related programs by running them via make variables so that the developer can substitute them with other alternatives:

<pre>
ar bison cc flex install ld ldconfig lex 
make makeinfo ranlib texi2dvi yacc 
</pre>

Those programs can be called by using these variables while writing the makefile:

<pre>
$(AR) $(BISON) $(CC) $(FLEX) $(INSTALL) $(LD) $(LDCONFIG) $(LEX) 
$(MAKE) $(MAKEINFO) $(RANLIB) $(TEXI2DVI) $(YACC) 
</pre>

=== Make Variables ===
Other <code>make variables</code> are:

<code>LIB</code> - this is the name of the library, also used to construct the .a target (e.g lib$(LIB).a)

<code>$(LIB)DEPENDS_ON_LIBS</code> - This is the list of libraries that this library DIRECTLY depends on. Usually it should be ok looking for #include fields checking if this lib directly depends on another library.

<code>$(LIB)PUBLIC_HEADERS</code> - the list of header files contained within this library that should be copied when the library is built or released.

<code>$(LIB)PRIVATE_HEADERS</code> - the list of header files contained within this library that should NOT be copied when the library is built or released.

<code>$(LIB)SRCS</code> - the list of source files contained within this library.

<code>$(LIB)INC</code> - the path used to search for include files.

<code>$(LIB)DIR</code> - base directory for the library

<code>$(LIB)HEADER_PREFIX</code> - the prefix that should be used when referencing a library header file using #include

<code>$(LIB)USER_FFLAGS</code> - FORTRAN compiler flags

<code>$(LIB)USER_CFLAGS</code> - C compiler flags

<code>$(LIB)USER_CXXFLAGS</code> - C++ compiler flags

Environment variables used within all makefiles:

<code>Flags :</code>

<code>ARCH_CFLAGS</code> - C compiler flags

<code>ARCH_CXXFLAGS</code> - C++ compiler flags

<code>ARCH_FFLAGS</code> - flags to the FORTRAN compiler

<code>Compilers :</code>>

<code>CXX</code> - C++

<code>CC</code> - C

<code>FF</code> - FORTRAN

<code>Other variables :</code>

<code>RELEASE_DIR</code> - it determines where where to release an application when "release" target has been definied

<code>RM</code> - usually used to remove one or more files

<code>CP</code> - usually used to copy one or more files

<code>USEPURIFY</code> - if set to anything, then the purify linker is used

<code>USEQUANTIFY</code> - if set to anything, then the quantify linker is used

<code>XRTHOME</code> - used to find path for XRT authorization

The developer is able to choose from two other variables that will semplify his work:

<code>$(CURDIR)</code>

This variable substitute the building folder (usually used in debian/rules file), to avoid errors while building the final package.

<code>DESTDIR</code>

This variable defines which will be the destination directory to make install applications files,for example, inside install target in debian/rules.

Other informations about variables can be found here: http://www.gnu.org/software/make

=== Target: Configure and config.status ===
Configure and config.status targets are really important, and usually if you have a good knowledge on those you'll be able to troubleshoot problems in an easier way. Config.status target depends obviously from configure and contains all commands that should be executed in a proper configuration. In debian/rules case, the default field is set to:

<pre>
./configure --host=$(DEB_HOST_GNU_TYPE) --build=$(DEB_BUILD_GNU_TYPE) --prefix=/usr --mandir=\$${prefix}/share/man --infodir=\$${prefix}/share/info CFLAGS="$(CFLAGS)" 
</pre>

Every developer can decide to configure the package using his own variables after ./configure command, to be able to decide where the package will install manpages, documents, binary files and so on. Other commands listed above can be used too. Common example is related to a "permission denied" error (adding a configure target with chmod a+x as command wont solve this problem) that happens while, during the build, rules file call for configure rule. In our case we are able to add "chmod a+x ./configure" just above the execution of ./configure itself, -under- "# Add here commands to configure the package." line. The configure and config.status variables only matter for a limited number of compiled programs and debian/rules file is one of them.

=== Target: Build ===
Let's move to describe each other target inside debian/rules file starting to understand what is, and why every rule is needed for a correct package build:

build takes care to perform all the configuration and compilation of the package. Usually this target is anticipated by configure/config one, that allows to configure source files before building them. Usually quite all applications contains their own configure script, that will be launched in config.status target under commands sections anticipated by a comment line:

<pre>
Add here commands to configure the package.
</pre>

Strictly related to build target are build-arch and build-indep, both of them are optional and can be dropped if not needed.

<code>Build-arch</code>

It takes care of configurating and compiling required for creating architecture-dependant binary packages, if the Architecture section is debian/control is not set to all.

<code>Build-indep</code>

Similarly to build-arch perform the configuration/compilation required for creating architecture-independent binary packages, if the Architecture section in debian/control is set to all.

<code>Binary target</code>

Takes care (must be invoked as root) of everything related to creating the binary package produced from source files. Usually it's a target with no commands to be specified, it's simply based on binary-arch and binary-indep dependencies, listed here:

<code>Binary arch</code>

Builds the binary packages which are specific to a particular architecture. Depends on build and install targets.

<code>Binary-indep</code>

Builds the binary packages which are -not- specific to a particular architecture. Depends on build and install targets. Both the Binary-arch and Binary-indep must exist, they *cannot* be dropped, also if one of them has nothing to do with the package, a developer is currectly working on.

=== Target: Clean ===
Clean target usually got no dependencies, but mainly contains only commands necessary to clean up the package after being built. When applying a patch system, like dpatch is obligatory to add unpatch as direct dependency, this will allow the clean process to de-apply changes provided by the patch system previously added. Clean target is usefull also for deleting generated manpages (or usually autogenerated config logs like config.status or config.log itself) from the build process, if not they will be stored in both source and debian folder. Here is what a clean rule looks like:

<pre>
clean: 
dh_testdir 
dh_testroot 
rm -f build-stamp 

Add here commands to clean up after the build process.
-$(MAKE) distclean 
-rm -f $(CURDIR)/foo.1 
-rm -f $(CURDIR)/config.log 
dh_clean 
</pre>

Let's analyse clean target closely, explaining what is and what it does every command listed there:

<code>dh_testdir</code>

Checks whether you are in the right folder to build the debian package, making sure that debian/control and others file the developer has specified really exists in that folder.

<code>dh_testroot</code>

Checks whether you are root as far as the package can be built only in root-mode, otherwise you're suggested to use a fakeroot system specifying it while running dpkg-buildpackage commmand. (e.g dpkg-buildpackage -rfakeroot).

<code>rm -f build-stamp</code>

Remove the generated files created by running make into sources folder, where application's makefile resides.

After executing this commands, the developer will be free to add any other command to clean up the package after comment:

<pre>
Add here commands to clean up after the build process.
</pre>

In our case, two commands have been specified (make distclean and dh_clean are specified by default). Basically we can summarize them as it follow:

<code>make distclean</code>

It's intended to return the concerned subset or directory to its pristine, or unbuilt state, removing all files potentially built by source's Makefile. It should not be used prior to install target, otherwise it will fail. (clean process won't stop)

<code>rm -f $(CURDIR)/foo.1</code>

This command will delete the generated manpage created under binary-arch commands by dh_installman (If source directory is named foo-1.0, $(CURDIR) variable will take its place during build process).

<code>rm -f $(CURDIR)/config.log</code>

This command will delete autogenerated logs created by launching ./configure command. It's safe to -not- have those files, to prevent confusing builds. As its shown they can be safely removed in clean target, alwais using previous folder variables. e.g $(CURDIR).

<code>dh_clean</code>

This command (part of debhelper) is responsible for cleaning up after a package has been built, removing build directories and other files like debian/substvars, debian/files and any other files related to debhelper command. (e.g debian/-.debhelper).

It's important to understand you won't find alwais this structure while making a new package as far as each package has different practices, setups and particolar needings.

=== Target: Install ===
Let's move to talk about the target responsible for installing procedures, named install. Here it is how install target looks like:

<pre>
install: build 
dh_testdir 
dh_testroot 
dh_clean -k 
dh_installdirs 

Add here commands to install the package into debian/foo.
$(MAKE) DESTDIR=$(CURDIR)/debian/foo install 
</pre>

Install target depends on build target, explained above. Let's get closer to the commands listed in the previous example:

<code>dh_clean -k</code>

In this case, dh_clean specifies the -k option, that prevent debian/dirs file to get deleted. This is necessary to be used anytime you have a debian/rules that has 2 binary targets that build different .deb packages. (e.g packaging libraries, one build target packages the shared libraries, other one -dev package.)

<code>dh_installdirs</code>

This command (part of debhelper) perform the creation of subdirectories in package build directories.

Note: <code>dh_destdir</code> and <code>dh_testroot</code> are explained above.

After executing this commands, the developer will be free to add any other command to install the package after the specified comment:

<pre>
Add here commands to install the package into debian/foo.
</pre>

In our case, by default is specified that the package will be installed inside debian/foo, taking foo as the name of the package we are creating. It will make install all files previously configured by the configure/config.status target and compiled by the build target into DESTDIR variable, that can be modified by the developer to suit his needs. Like the clean target, the folder that contains sources files need to be specified not using the local uri, e.g /home/bar/foo/debian/foo but using the $(CURDIR) variable, recognized universally by build systems like pbuilder.

Install target allows the developer to launch debhelper's scripts that will install and place every file in the correct location. I suggest you to check debhelper or dh_- scripts man page available by running man command in a terminal followed by man page section (1-8) and application name (e.g man 1 dh_-).

=== Target: PHONY ===
Another important part of debian/rules file but generally of the whole world of makefiles are PHONY targets; targets which don't actually create a file, but do something.

You can have add "phony" targets to your debian/rules file too (usually are placed by default as end line); targets which don't actually create a file, but do something. These are created like normal targets: for instance, to add a "all" target to our makefile we would add :

{{{ 
all: foo 
}}}

Make sure that file "all" it's not your build directory, if not the rule won't run correctly. So we can tell make that this is a phony target and should be rebuilt always this is by using the target .PHONY. so, we can add to our Makefile:

<pre>
.PHONY: all 
</pre>

In fact these rule's commands won't create any target file, but will be executed every time the target comes up for remaking. Common example is the clean one:

<pre>
.PHONY : clean 
clean: 
rm -.h 
</pre>

Once this has been definied, <code>make clean</code> will run the commands with every file named <code>clean</code>.

=== Usefull Links ===
If you liked this wiki page and you want to learn more about makefiles or generally debian policies, I suggest you to look at these usefull links around the web to intensify your future work on debian/rules file, but generally on makefiles:

# Gnu Make Official Guide: http://www.gnu.org/software/make/
# Packaging Policy: http://www.debian.org/doc/maint-guide/
# Debian Source Policy: http://www.debian.org/doc/debian-policy/ch-source.html

----
CategoryPackagingGuide
