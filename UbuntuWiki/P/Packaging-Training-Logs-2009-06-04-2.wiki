{|
| '''Warning'''
* This is a '''readonly''' and '''text-based''' archive of a deprecated wiki.
* '''Images''' and '''attachments''' have been removed to conserve space.
* '''Links''' may not work.
* A '''full compressed version''' of the wiki is available on archive.org
|}

__TOC__


{{{#!IRC
[15:59] <@mvo> welcome everyone - and sorry that I could not make it this morning
[16:00] <@mvo> and a special thanks to dholbach for doing a Q&A
[16:00] <dholbach> mvo: no worries :)
[16:01]  * iulian m00s
[16:01] <@mvo> I'm going to talk about how to make package upgrade cleanly
[16:01] <@mvo> I will give a overview on the common problems I see when looking at upgrade failure logs
[16:02] <toabctl> hi
[16:02] <@mvo> on the bright side: dpkg/apt tend to do pretty well - but if stuff goes wrong recoverying is not a great user experience
[16:02] <@mvo> so we should try to make sure that stuff does not get wrong :)
[16:02] <keffie_jayx> o/
[16:02] <@mvo> (and improve our tools to deal better with failures)
[16:03] <@mvo> if you have any questions or special topics that you would like to talk about, just ask here (or in #ubuntu-classroom-chat)
[16:04] <Rinia> hello everybody
[16:04] <@mvo> I prepared some notes, if there are no questions/comments I will just paste a bit into the channel
[16:04] <keffie_jayx> :D
[16:05] <@mvo> = How to make packages upgrade cleanly =
[16:05] <@mvo> Normal deb packages usually upgrade just fine, dpkg takes care of all the heavy lifting and shuffling of files. The most common source of problem on upgrades are:
[16:05] <@mvo> • file overwrite problems (e.g. when a package was split)
[16:05] <@mvo> • maintainer script problems
[16:05] <@mvo> A general good advise is to keep the amount of code in the maintainer script small and clean. Shell is a language that can be tricky and a failure in the script will make the upgrade abort and gives the user a bad experience.
[16:07] <@mvo> the most common source of overwrite problems are caused by package splits
[16:08] <dholbach> mvo: why are package split? does that happen very often? is ther an example? :-)
[16:08] <@mvo> but they can also happen if two package just happen to install the same file into the same location. if that can not be avoided (e.g. by changeing the program to look into a different location) the package can not be installed in parallel and should conflict
[16:08] <@mvo> for a package split we use a different technique
[16:08] <@mvo> dholbach: thanks, I give a example now :)
[16:08] <@mvo> == Package splits ==
[16:08] <@mvo> If a package foo gets split into two packages like foo and foo-common there needs to be a "Replaces" line in the "foo-common" package. The reason is that on upgrade, the new package "foo-common" may get installed when the old "foo" is still installed. Because the foo-common has files that belong to the old foo dpkg will complain if the proper "Replaces" line is missing.
[16:08] <dholbach> woohoo
[16:09] <@mvo> this is pretty common for projects that start out as e.g. update-manager and then later grow new frontends (like udpate-manager-text). then the package typically gets split into update-manager-common, update-manager-gtk, update-manager-text etc
[16:10] <@mvo> Example:
[16:10] <@mvo>  foo 1.0 is a big package
[16:10] <@mvo>  foo 1.1 is split into foo and foo-common
[16:10] <@mvo> foo-common now needs a line:
[16:10] <@mvo> Replaces: foo (<< 1.1)
[16:10] <@mvo> to ensure that if the new foo-common is unpacked before the foo package is upgraded everything still works as expected.
[16:10] <neurobuntu> how does (<< 1.1) differ from (< 1.1) ?
[16:13] <@mvo> neurobuntu: the "<" is a older (and now deprecated way) of expressing the same. it used to mean earlier-or-equal
[16:13] <@mvo> neurobuntu: but its a bit confusing, this is why "<<" and "<=" etc are now used
[16:13] <@mvo> The most common case is something like the following for "foo":
[16:13] <@mvo> Depends: foo-data (= ${source:Version})
[16:13] <@mvo> This means that dpkg needs to unpack foo-data first before it unpacks the new foo. So without the Replaces line above it will not work.
[16:13] <neurobuntu> ok thanks
[16:14] <@mvo> cheers
[16:15] <@mvo> any questions on this particular bit (splitting/overwrite problems)?
[16:15] <@mvo> I should note that we have a system that can check for file conflicts in the archive, but its currently in the need for some bugfixing
[16:16] <dholbach> what is a good way to test if my packages upgrade well? is  dpkg -i *.deb  good enough?
[16:17] <@mvo> dholbach: yes, that is a good way. its a good way of testing before a upload to make sure the current version is installed
[16:17] <@mvo> and then install the new package like this
[16:17] <@mvo> the good news is that for the common case (package just got some new files/some old files got removed) dpkg will do everything
[16:17] <@mvo> and we do not have to worry
[16:18] <@mvo> testing is always good, its pretty anoying if a forgoten "fi" in a maintainer script causes problems later :)
[16:18] <@mvo> which brings me to the next topic:
[16:18] <@mvo> == Maintainer script problems ==
[16:19] <@mvo> We have two classes of issues here
[16:19] <@mvo> one are "just" bugs
[16:19] <@mvo> a forgoten "fi"
[16:19] <@mvo> the use of bash syntax (like "==")
[16:20] <@mvo> instead of POSIX (which expects "=")
[16:20] <@mvo> etc
[16:20] <@mvo> (we use dash as /bin/sh so we need to be careful with that, some other distros do not have this problem)
[16:22] <@mvo> the other class of problems is that the system is in a flux during a complex upgrade (like a upgrade from 6.06 -> 8.04 :)
[16:22] <dholbach> mvo: what are maintainer scripts? is there a good way to test them? :)
[16:22] <@mvo> dholbach: good point, sorry for using jargon :)
[16:22] <dholbach> (I hope everybody else feels free to pester mvo with questions too and it's not just me. :-))
[16:23] <@mvo> maintainer scripts are the scripts known as: "prerm, postrm, preinst, postinst"
[16:23] <@mvo> they are run as part of the package installation
[16:23] <toabctl> mvo, are they makefiles? or just shellscripts?
[16:23] <@mvo> they can contain any shell code and are used for stuff like "ldconfig"
[16:23] <@mvo> toabctl: usually shell scripts, some contain perl too (notable stuff that uses debhelper)
[16:24] <neurobuntu> when upgrading a package, are the prerm and postrm run (almost like the old package is removed before the new is installed)?
[16:25] <@mvo> neurobuntu: yes they are. I have a example for this in a bit, it can become relatively complex
[16:25] <@mvo> a maintaner script may alter the system state in any way, this is why we do not support rollbacks or downgrades in a general way. because it may simply be not possible to undo (or know) what a maintainer script did
[16:25] <@mvo> (but that is just a side note :)
[16:26] <dholbach> mvo: is there any way to test them or do I just re-install the package to see if it worked?
[16:26] <@mvo> dholbach: they can be tested by running them with the approprate arguments (simulating the way they are called by dpkg). this can be very helpful, especially when run with "sh -x" to see line by line what is actually happening
[16:27] <@mvo> I will give a example for this
[16:27] <@mvo> Problems here are usually caused by the fact that the system is in a pretty unusual state during a upgrade. Some packages are half-installed, some are not available etc. Maintainer scripts should not make too many assumptions about the system because during a upgrade those may well be wrong. A script should gracefully whenever possible.
[16:27] <@mvo> Its useful to know how maintainer scripts get called:
[16:27] <@mvo> http://debid.vlsm.org/share/Debian-Doc/debian-policy/ch-maintainerscripts.html has all the details in Section "6.5".
[16:27] <@mvo> The way apt works is that it splits the changes into dpkg runs that get called with "--unpack" and then "--configure". On a typical upgrade, this is:
[16:27] <@mvo> Unpack:
[16:27] <@mvo> •  old-prerm upgrade new-version
[16:27] <@mvo> • new-preinst upgrade old-version
[16:27] <@mvo> • files from the new package are now in place
[16:27] <@mvo> • old-postrm upgrade new-version
[16:27] <@mvo> Configure:
[16:27] <@mvo> • postinst configure most-recently-configured-version
[16:28] <@mvo> neurobuntu: I hope the table below anser the earlier question
[16:28] <neurobuntu> yes it does
[16:28] <@mvo> so quite a bit of script that are run :)
[16:28] <@mvo> and if something goes wrong, it gets even more complext, if e.g. the old-prerm fails, the new-prm is called
[16:28] <neurobuntu> what is the logic behing running the new preinst and copying the new files before running the old-postrm
[16:28] <@mvo> this can be useful when recovering from a mistake in a maitainer script
[16:32] <@mvo> neurobuntu: a good question. I currently do not have a good example, generally the postrm is there to do final cleanup
[16:33] <@mvo> useful for e.g. update-menu or something similar that updates the debian menu and needs the new menu files to get reliable data
[16:34] <@mvo> (not the best example in the world I guess :)
[16:34] <@mvo> The time between unpack and configure can be pretty long (on release upgrades) because apt tries to put as much work into a single dpkg run as possible (to speed things up, dpkg invocation is slow).
[16:34] <Rail> FYI, detailed information about maintainer scripts can be found at http://www.debian.org/doc/debian-policy/ch-maintainerscripts.html
[16:36] <@mvo> Rail: thanks! especially section 6.6 is interessting here
[16:36] <@mvo> This can be tricky if critical functionality relies on the work that is done in configure. A example is python when the symlinks get removed in preinst and re-created in postinst. This means that the package python functionality is not available during a release upgrade (people can not play certain gnome-games ;) Its also common for daemons that stop in preinst and start again in postinst). Often this is unavoidable, but it should be kept
[16:36] <@mvo>  in mind when thinking about the package maintainer scripts.
[16:37] <@mvo> generally I would recommend writing small and simple maintainer scripts if at all possible, the less complexity the less likely are bugs :)
[16:38] <dholbach> mvo: is there a way to avoid maintainer scripts easily?
[16:38] <@mvo> debhelper takes care of a lot of this
[16:38] <@mvo> e.g. the ldconfig scripts are all auto generated
[16:39] <@mvo> or the python magic
[16:39] <@mvo> or init stuff
[16:39] <dholbach> or is there a way around having to write (really good) shell scripts? :)
[16:39] <@mvo> and thats good, auto-generated code is nice because it needs to be fixed only in one place if a errorr is found
[16:40] <@mvo> another new development is the increased use of triggers
[16:40] <neurobuntu> triggers?
[16:40] <@mvo> triggers are a way to express a interessted in a certain directory for example
[16:41] <@mvo> its a relatively new concept
[16:41] <neurobuntu> ok i'll be sure to read up on them
[16:41] <@mvo> a package like e.g. "man-db" tells dpkg that its interessed in changes in /usr/share/man
[16:41] <@mvo> and everytime a file is installed there, dpkg will notice that and mark the trigger as pending
[16:42] <@mvo> then dpkg will run the pending triggers at the end
[16:42] <@mvo> (or when needed)
[16:42] <@mvo> so it runs the man-db.postinst with "triggered" as argument
[16:42] <@mvo> and the man-db package then processes the new man-pages and builds a db from them
[16:43] <neurobuntu> so man-db says its interested in /usr/share/man I install package foo which installs /usr/shar/man/foo.man and then dpkg runs the man-db.postinst?
[16:43] <@mvo> this is a very useful concept because it means that mandb can be run when everything else got installed (needs to be run only once)
[16:43] <@mvo> neurobuntu: yes
[16:43] <neurobuntu> wow thats really slick!
[16:44] <@mvo> neurobuntu: re "configure" (from #ubuntu-classroom-chat")
[16:45] <@mvo> the configure here is something different, it just shares the same name with the autotools configure
[16:45] <@mvo> dpkg roughtly splits a package into "unpacked" and "configured"
[16:45] <@mvo> unpack means the files are in place
[16:45] <@mvo> configured means that the package is actually usable
[16:45] <@mvo> the switches are "dpkg --unpack $long_list_of_packages"
[16:46] <@mvo> and dpkg --configure $long_list_of_packages"
[16:46] <@mvo> in a way, this is a performance optimization to avoid having to call dpkg too often
[16:47] <@mvo> each time dpkg is run it builds a (internal) database of all installed files and the relations
[16:47] <@mvo> that can be time consuming
[16:47] <@mvo> so the less times dpkg needs to be called, the better
[16:47] <neurobuntu> ok that makes sense...  forgive me if you answered this earlier but after the files are in place (dpkg --unpack),  preinst gets run?
[16:48] <neurobuntu> or are all the preinst scripts run before the unpack happens and then all the postinst scripts are run?
[16:49] <@mvo> neurobuntu: the preinst script gets run before the new files are in place. this can cause bugs, we had a package that tried to start a daemon in preinst, but the daemon was not on disk yet, so the package was not installable (or rather, installed, but always gave a error message)
[16:49] <@mvo> ia: thanks for your question - this is a tricky one
[16:50] <neurobuntu> ok thanks
[16:50] <neurobuntu> this is making sense
[16:50] <@mvo> ia: the python problem we had were hard to reproduce because the system is in so much of a flux during a upgrade. its tricky to get this right. in my experience jaunty-final did pretty well and the cases of failure were rare
[16:50] <@mvo> but its a good example why complexity in maintainer scripts is generally something that may not work so well
[16:51] <@mvo> because its hard to predict the environment in which the script is run, that may depend on the installed packages on the system that is upgraded etc
[16:51] <@mvo> very hard to reproduce
[16:52] <@mvo> what we can  do now is upgrade-testing on real HW
[16:52] <@mvo> there is a update-manager --sandbox switch
[16:52] <@mvo> for jaunty->karmic upgrades
[16:53] <@mvo> that will perform a upgrade into a writeable filesystem snapshot in /tmp - but it keeps the real system unchanged (or rather, restores it on the next reboot)
[16:53] <@mvo> this is quite useful to test real world upgrades
[16:53] <@mvo> chroots (e.g. pbuilder login) or other tests are useful too
[16:54] <@mvo> we plan to have a auto-upgrade-tester package for karmic that can be used to test system upgrades of any given input packages, lets see how this goes :)
[16:54] <@mvo> I guess the summary is: the best way for us (as a distro) to ensure clean upgrades is lots of testing (on a wide range of setups)
[16:55] <@mvo> for the maintainer: write good, clean, small maintainer scripts :)
[16:56] <ia> mvo: ok, thanks :-)
[16:56] <@mvo> (for the specific python problem we plan to change the way the python packages are done to invlove a little bit less magic :)
[16:56] <@mvo> for karmic
[16:57] <neurobuntu> mvo thanks this has been really helpful
[16:58] <@mvo> thanks for comming and listening!
[16:58] <@mvo> and asking good questions of course :)
[17:00] <@mvo> ia: the auto-upgrade-tester is a project that can perform a full upgrade in a virtual environment
[17:00] <@mvo> it can use chroot, kvm and ec2 (the later is still a bit experimental)
[17:00] <@mvo> kvm is really the most useful one
[17:01] <@mvo> you give it a base image that can be any kvm image (e..g build via ubuntu-vm-builder) and then it will perform a release upgrade from the installed version of ubuntu to the next using update-manager in a non-interactive session
[17:01] <@mvo> that takes ~1h on my realatively slow system
[17:02] <@mvo> after that I can see if the given image upgrades cleanly or if there are issues
[17:02] <@mvo> its very useful as a QA tool
[17:02] <@mvo> its currently only available via bzr, but we want to package it
[17:02] <@mvo> so that everyone can test and play with it
[17:03] <@mvo> the base-image is not touched, so when a failure happen a fix can be tested as well with it
[17:04] <@mvo> e.g. when python-foo does not upgrade cleanly (but only in a complex dist-upgrade), a fix can be uploaded to a test PPA and the upgrade can be pointed to that PPA to test if the fix is really good
[17:04] <@mvo> does that answer the question? or should I expand on a particular are more?
[17:04] <@mvo> area
[17:05] <ia> mvo: yep, thanks for answer :-)
[17:05] <@mvo> :)
[17:10] <@mvo> if there are no further question I say thanks for comming and have a good day
[17:10] <Rail> mvo: thank you
[17:10] <Rail> and others for questions
}}}
----
CategoryPackaging
