{|
| '''Warning'''
* This is a '''readonly''' and '''text-based''' archive of a deprecated wiki.
* '''Images''' and '''attachments''' have been removed to conserve space.
* '''Links''' may not work and there may be formatting issues.
* A '''compressed''' version with images and the original syntax is in the repo '''Releases'''.
|}

__TOC__


If you have ever lost a file or need to find one, searching manually can be frustrating. Here are some ways to use Ubuntu to do your searching for you.

=== Graphically ===

==== Places --> Search for Files ====

If you need to search for a file on the computer, there is an easy and built-in way to do it. Launch the Search for Files program from the Places menu. By default, this will only search your files (your home directory), but you can tell it to search in other folders with the ''Look in folder'' dropdown. This will only search on file names. If you want to search inside file, see the next section on Beagle.

==== Thunar (File Manager for Xubuntu) ====

In Xubuntu 7.10, Thunar is not initially set up with a file-searcher.  There are a number of file-searchers that can be set up, but I will explain how to set up the gnome-search-tool.

1. Install 'gnome-utils' using Synaptic Package Manager

2. In Thunar, choose 'Edit'/'Configure Custom Actions' and add a new custom action with the name 'Search for Files' and the command 'gnome-search-tool --path=%f'.  Under the 'Appearance Conditions' tab, tick 'Directories' - this is important.

You will now be able to tick on any directory in the '''right''' pane, and choose 'Search for Files'.  This file-searcher has many different options for doing advanced searches.

==== Tracker ====

Tracker is an indexing system. It will keep track of all your files and their contents and allow you to quickly find files on your computer. For more information see <nowiki>[[Tracker]]</nowiki>.

==== Beagle ====

Beagle is also indexing system, designed to help you search inside your files. It is not installed by default. For more information on installation, see <nowiki>[[Beagle]]</nowiki>.

==== Recoll ====

Beagle is also indexing system. It is a full text search package based on a very strong backend (Xapian), for which it provides an easy to use and feature-rich interface. It is not installed by default. For more information on installation, see <nowiki>[[Recoll]]</nowiki>.

=== Command Line ===
There are a number of command line tools to help you find a file on system.

==== apt-file ====
The first method is for finding files that are (or should be) provided by Ubuntu's packages.  If you're not familiar with the file being complained about, odds are good that it falls into this category.  The apt packaging system is aware of almost all the files it provides and can be queried to learn what package provides a given file and where that file is (or should be).  To take advantage of this feature, install the package <code>apt-file</code> and then run <code>apt-file update</code> in a terminal.

Now, say you've been trying to compile a new kernel module, and its build system complains at you that there's "No such file or directory - version.h" or some such.  You could "apt-file search version.h", but that would be a pretty broad search and would return such files as subversion.html.  You can guess that this file has something to do with the kernel, and I happen to know that in a fully prepped kernel tree, it should be found in a directory called "linux", so I say "apt-file search linux/version.h" and find just what I was looking for: which package I need to install to have the file I need.  See the apt-file man page for some handy options like case-insensitive searching and regular expression matching.

==== dpkg -L ====
Maybe you suspect that the file in question is supposed to be provided by the same package you're working with.
<pre>
dpkg -L <packagename>
</pre>
will show you a list of files provided by that package.  For example, you've just installed kxdocker_0.32-1_i386.deb and your first guess, "kxdocker", doesn't run the program.
<pre>
$ kxdocker
-bash: kxdocker: command not found
</pre>
Well it's in there somewhere:
<pre>
$ dpkg -L kxdocker | grep bin
/usr/local/kde/bin
/usr/local/kde/bin/kxdocker
</pre>
Ah, it's there, but /usr/local/kde/bin isn't in your $PATH.  Now you know that you can add it to your $PATH or run the command with the full path.

==== dpkg -S ====
Sometimes you might want to find out which package provides a certain file.
<pre>
dpkg -S /full/path/to/file
</pre>
will show you the package.
For example,
<pre>
dpkg -S /usr/bin/gnome-keybindings-properties
gnome-control-center: /usr/bin/gnome-keybinding-properties
</pre>
tells you that gnome-keybinding-properties is provided by the package gnome-control-center.

==== find ====
The Unix command "find" is quite powerful, and if you know how to use it you can find pretty well anything.  The basic syntax is "find <path> <options>".  Options include criteria for your search, actions to take on files found, etc.  I'll give you a couple of examples then point you to the man page for detailed usage and more interesting examples.

You want to find every file in ~/mydir and all its subdirectories, recursively, with a file extension of .htm (or .HTM or .Htm...) and delete it.  I've seen a lot of attempts like rm -rf ~/mydir/*.htm which really don't come close.  The correct solution is
<pre>
find ~/mydir -iname '*.htm' -exec rm {} \;
</pre>
"-iname" says that you want to do a case-insensitive search on the filename.  '*.htm' is in single quotes to prevent bash from expanding the *, which will produce unexpected results.  The rest of the command says to remove any file matching the query.  The "{}" will be replaced by the filename (with path) returned by the search, and "\;" will separate one rm command from the next.  Nearly every -exec option should be terminated with a "\;".

Now you want to fix permissions.  For some reason, there seem to be directories in your home directory that you don't have permission to enter.  You know that the operative bit for directories is the execute bit.  You know that "chmod -R +x ~" will add the execute bit to every file and directory in ~ (or $HOME), but you only want to operate on directories - BritneySpearsOopsIDidItAgain.avi doesn't need to be executable.  This is solved with:
<pre>
find ~ -type d -exec chmod +x {} \;
</pre>
where "-type d" of course means directories.

Finally, you want to make a playlist out of all the mp3 and ogg files in your home directory.
<pre>
find ~ -type f \( -iname '*.mp3' -o -iname '*.ogg' \) > mynewplaylist.m3u
</pre>
We group the -iname parameters in parentheses and separate them with -o (the "OR" operator) to say that any match must be a file, AND it must be named .mp3 OR .ogg (case-insensitive) to be returned.  We redirect the output to a new file called mynewplaylist.m3u, and presto! We have a playlist.

==== locate ====
Oh, where did I put that file?  I've got directories and partitions all over the computer where I put files, and they're not quite well-organized enough for me to figure out where I put resume.doc last year when I was job-hunting.  I don't want to use "find" because it'll take forever to search my entire computer.  I can't use apt-file because resume.doc is not provided by any Ubuntu package.  Thankfully my computer indexes all my files every night while I sleep and I can search just the index, which will take only a few seconds, even on as an expansive a filesystem as mine.  Of course the software needs to be installed ("sudo apt-get install slocate").  If I look at root's cron jobs ("sudo crontab -e") I see that the slocate package has been faithfully updating my index
<pre>
02 4 * * * /usr/bin/updatedb -e /mnt/data,/mnt/files
</pre>
every night at 4:02am, excluding /mnt/data and /mnt/files, which are remote Samba mounts that I prefer not to index.  So as long as my resume is on one of my local mounted filesystems, I should be able to find it.
<pre>
locate resume.doc
</pre>
It's that simple, unless I'm not quite sure about the spelling, in which case I might use -i for a case-insensitive search or -r to use a POSIX regular expression.

==== which and whereis ====
Two more commands that occasionally come in handy are "which" and "whereis".  "which" will search your $PATH ("echo $PATH") for a given command and return the first match - the one that will be run if you specify the command without a path.  "whereis" will return any and all binaries, sources and man pages associated with the argument you give it.  "which" can come in handy for example if you've installed the same software via apt-get and again from source.  Very likely you'll have the same command in two different places, and "which" can help you figure out why the version you thought you updated to isn't running.  If you have "xchat" in both /usr/bin and /usr/local/bin, "which" will tell you what will happen when you just run "xchat".  "whereis" will show you both, plus any man pages and (depending on the circumstances) the source tree from which you compiled it.

Gnome, KDE etc. have numerous utilities for finding files, and their usage is left as an exercise for the reader.  Learn how to use these commands effectively and I predict you'll forget those graphical utilities ever existed.

----
