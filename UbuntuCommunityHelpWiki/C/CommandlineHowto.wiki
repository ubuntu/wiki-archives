{|
  | '''Warning'''
  * This is a '''readonly''' and '''text-based''' archive of a deprecated wiki.
  * '''Images''' and '''attachments''' have been removed to conserve space.
  * '''Links''' may not work and there may be formatting issues.
  * A '''compressed''' version with images and the original syntax is in the repo '''Releases'''.
|}

__TOC__


== Introduction ==
Even though Ubuntu is a newbie friendly and polished graphical distribution, there are still situations where a significant amount of time and mouse-clicking can be spared by typing a bit. I don't think this is a bad thing at all; no matter what you do, Linux has one of its real strengths in the Command Line! :) 

=== Prerequisites ===
This assumes that you are running any version of Ubuntu Linux and have a desire to learn its inner workings.  We will proceed by briefly describing the command line interface and giving some history.<<BR>>

/!\ The impatient can move right on to the '''Command Syntax''' section.

=== What is it? ===
A Command Line is, in all simplicity, a user interface based on lines of commands. You can say that it is a '''textual direct serial processor'''. Most commonly, the user interacts directly with the computer by typing one line (although it can be more than one), which triggers actions from the computer based on the syntax of the current processor.<<BR>>

=== History ===
In the early days of computers, there was only the Command Line. The concept of a Graphical User Interface (GUI) after which most GUI are modeled was developed by engineers at '''Xerox's Palo Alto Research Center (PARC)'''. A bit later, Apple paid a whole bunch of money to be allowed to "study" their GUI idea. And, after a while, Apple had their own GUI. 

Not until 1986 did UNIX get its first GUI, developed by the '''MIT Project'''. They named it X. Linux, however, had to wait ten more years before XFree86 was released. XFree86 was (and remains) a free adaptation of the original X server.

As mentioned earlier, the CLI (Command Line Interface) was the only way to communicate with computers before the GUI was invented. In 1969, '''Bell Telephone Laboratories''' released V1 of the UNIX Timeshare System. UNIX had a shell called sh, which was the only means of communicating with the computer, and it would stay that way for quite some time.

Later on, there came derivatives of UNIX: HP-UX, 1BSD, Solaris, OpenVMS, IRIX, SCO XENIX, etc. As time progressed, GNU/Linux emerged. However, the history of Linux itself is way off the scope of this HOWTO. Suffice to say that alternative CLI to sh emerged: zsh, ksh, bourne shell, etc.

==== POSIX ====
The Wikipedia defines POSIX as the following:

 POSIX is the collective name of a family of related standards specified by the IEEE to define the application program interface (API) for software designed to run on variants of the Unix OS. They are formally designated as IEEE 1003 and the international standard name is ISO/IEC 9945. The standards emerged from a project, begun circa 1985. The term POSIX was suggested by Richard Stallman in response to an IEEE request for a memorable name; before that the standards effort was called IEEE-IX. POSIX is a near acronym for Portable Operating System Interface, with the X signifying the Unix heritage of the API.

POSIX is the underlying standard and functionality of how your CLI responds.

=== Advantages of using the command line ===
So, CLI preceded GUI as a computer interface.  Since GUIs are common now, why should we still care about CLI?  Some advantages of using the command line are:

* It can save you time.
* It can help when you are unable to use the GUI, such as a system crash or a configuration issue.
* It can enable you to use Linux in ways that using a GUI exclusively can not (such as scripting repetitive tasks). 
 
For example, you have been called by the systems administrator that you have used too much space.  You want to quickly work out where the most space is used, so using a graphical interface, start your timer - go.  Now, go to a command line and type: `du | sort -n` (we will describe more later). See? It is faster to do some things on the command line (and other times, easier for graphical).

 
=== How to invoke it ===
Methods of launching a CLI can vary by desktop environment: <<BR>>

'''Unity (Ubuntu 14.04)''' <<BR>>
 ''Dash -> Search for Terminal''<<BR>>
 ''Dash -> More Apps -> 'See More Results' -> Terminal''<<BR>>
 ''Dash -> More Apps -> Accessories -> Terminal''<<BR>>

'''Gnome Desktop (Ubuntu GNOME)'''<<BR>>
 ''Activities -> Search for Terminal''<<BR>>

'''KDE Desktop (Kubuntu)'''<<BR>>
 ''KDE Menu | Applications | System | Konsole Terminal Program''<<BR>>

'''XFCE Desktop (Xubuntu)'''<<BR>>
 ''Applications | System | Terminal''<<BR>>

An alternative way to invoke the command line, only using keyboard shortcuts (''since on the command line, you would mostly be interacting only through the keyboard'') is:

On Unity (Ubuntu): <code>Ctl</code> + <code>Alt</code> + <code>T</code> '' <<BR>>
On GNOME (Ubuntu): <code>Alt</code> + <code>F2</code> -> (''Type within the text box'') gnome-terminal (Press ''return'') <<BR>>
On KDE (Kubuntu): <code>Alt</code> + <code>F2</code> -> (''Type within the text box'') konsole (Press ''return'') <<BR>>

=== Basic structure and concepts ===
The first thing that you should notice is something like:
<pre>
dud@shadowplay:~ $
or
[dud@shadowplay ~]$
</pre>
What you see here is called the prompt. It signifies that the computer is ready and awaiting user input. In my case, '''dud''' is the user that I'm logged in as. '''shadowplay''' is the computer's hostname, and '''~''' is the current directory (the user's home directory).

Concepts:
* A terminal is a "physical" (direct) interface to your Linux Operating System.
* A terminal emulator is what we'll be using here. This is a CLI wrapped within your running GUI. Any applications running in a terminal emulator will be killed if you close the terminal emulator.
* A shell is an interpreter for commands entered into the terminal. 
* A command is usually a small utility that the shell will execute for you.
* Output is what a command returns; most often this is returned on the terminal.
* Input consists of the arguments or data that any given command will take. Input will change the way a given command acts.
* A process is a running application on your computer. It can be active, sleeping, or in a number of other states.

== Command Syntax ==
This section will try to give you a good rundown of the basic usage for the bash shell, which is the default user shell in Ubuntu.

=== Single Command ===
The command syntax will vary with each command. Here are some of the basics.

The simplest way to use some commands is to type just the command.<<BR>>

 '''command'''

Example:

<pre>
dud@shadowplay:~ $ ls
file1.txt
file2.pdf
file3.mp3
file1.pdf
another_file.txt
Yet-Another_file.txt
file-with_other-NAME.TXT
</pre>

The above example displays the contents of the current working directory, while other commands may require one or more arguments.

 '''command <argument>'''

Example:

<pre>
dud@shadowplay:~ $ cat file1.txt
Roses are red.
Violets are blue,
and you have the bird-flu!
</pre>

The above example shows you the content of the file1.txt file by adding the filename as the argument for the ''cat'' command. Almost all commands, whether they have arguments or not, have options.

 '''command -option'''

Example:

<pre>
dud@shadowplay:~ $ ls -r
file-with_other-NAME.TXT
Yet-Another_file.txt
another_file.txt
file1.pdf
file3.mp3
file2.pdf
file1.txt
</pre>

Using the previous example of showing the current directory, we have added the ''-r'' option. As you can see, the listing of the current working directory has been displayed in the reverse order.

It is also possible to pass more than one argument or option to the command, depending on whether the program accepts more or not. If you want to pass two arguments or options consecutively, then you would use the following syntax:

 '''argument1 argument2'''

or

 '''-option1 -option2'''

=== Multiple Commands ===
Sometimes the desired task may require the use of more than one command to be completed. Here is the syntax for the use of multiple commands.

If you want to execute two commands consecutively, then you would use the following syntax:

 '''command1 ; command2'''

Example:

<pre>
dud@shadowplay:~ $grep red file1.txt ; grep blue file1.txt
Roses are red,
Violets are blue,
</pre>

In the example above, command1 and command2 are executed. However, if you need command1 to complete successfully before executing command2, then you would use the following syntax:

 '''command1 && command2'''

Example:

<pre>
dud@shadowplay:~ $ grep red file1.txt && grep blue file1.txt
Roses are red,
Violets are blue,
dud@shadowplay:~ $ grep purple file1.txt && grep blue file1.txt
dud@shadowplay:~ $
</pre>

In the example above, you will notice nothing happened when the first command did not complete successfully. If you want command2 to execute only if command1 fails, then you would use the following syntax:

 '''command1 || command2'''

Example:

<pre>
dud@shadowplay:~ $ grep red file1.txt || grep blue file1.txt
Roses are red,
dud@shadowplay:~ $ grep purple file1.txt || grep blue file1.txt
Violets are blue,
dud@shadowplay:~ $
</pre>

In the example above, you will notice command2 was only executed when command1 failed.

=== Wildcards ===
Wildcards are a useful feature that allows an unknown value or values to be used with another command. This becomes very useful with commands such as "ls" allowing only a range of filenames to be displayed.

There are three operators used with wildcards - "*", "?" and "[x-y]". 

==== Specifing a single character ====
The "?" is used to represent a single unknown character, consider we have a folder containing four files: file1.pdf, file2.pdf, file2.mp3 and file23.pdf. If wanted to know which PDF filenames contained numbers, then we could use:

<pre>
dud@shadowplay:~ $ ls file?.pdf
file1.pdf
file2.pdf
</pre>

==== Specifying multiple characters ====
Using the same files as the previous example, if we wanted to search for all files called "file2" of any type we could:

Example:

<pre>
dud@shadowplay:~ $ ls file2.*
file2.pdf
file2.mp3
</pre>

==== Specifying a range ====
If we wanted to know all PDF filenames beginning with "file" and a number between 2 and 23 then we use:

<pre>
dud@shadowplay:~ $ ls file[2-23].pdf
file2.pdf
file23.pdf
</pre>

=== Control Flow ===
Commands read input from the keyboard (standard input, or stdin) and write to output (standard out, or stdout). There is also a special output category for error messages called standard error (or stderr). These three locations are created automatically for each program. 

We can redirect input and output to and from a command. 

==== Redirection ====
If you wanted the output of a command to go to a file instead of the terminal, then you would use the following syntax:

 '''command > filename'''

Example:

<pre>
dud@shadowplay:~ $ ls > file4.txt
dud@shadowplay:~ $ cat file4.txt
file1.txt
file2.pdf
file3.mp3
file1.pdf
another_file.txt
Yet-Another_file.txt
file-with_other-NAME.TXT
file4.txt
</pre>

The above example will create file4.txt if it is not found. '''NOTE:''' If file4.txt exists already, the above command will overwrite its contents. If you want to add to the end of a existing file, then you would use the following syntax:

 '''command >> filename'''

Example:

<pre>
dud@shadowplay:~ $ ls >> file4.txt
dud@shadowplay:~ $ cat file4.txt
file1.txt
file2.pdf
file3.mp3
file1.pdf
another_file.txt
Yet-Another_file.txt
file-with_other-NAME.TXT
file4.txt
file1.txt
file2.pdf
file3.mp3
file1.pdf
another_file.txt
Yet-Another_file.txt
file-with_other-NAME.TXT
file4.txt
</pre>

In the example, you will notice the file was appended with the new information. 

But bash takes it even further. You will have noticed that ls can produce error messages if a directory ls is suppose to list does not exist or the user lacks access rights. In bash, Error messages and the "regular results" (i.e. dir listing) are 2 separate streams. To ease use of results only find a detailed explanation of <nowiki>[[bash]]</nowiki>.

Now we are going to do a different redirection: We are going to take the input from a file for the command to be executed. Here is the syntax for this redirection:

 '''command < filename'''

Example:

<pre>
dud@shadowplay:~ $ sort < file4.txt
another_file.txt
another_file.txt
file1.txt
file1.txt
file2.pdf
file2.pdf
file3.mp3
file3.mp3
file4.txt
file4.txt
file-with_other-NAME.TXT
file-with_other-NAME.TXT
Yet-Another_file.txt
Yet-Another_file.txt
</pre>

As you can see from this example, we used the file4.txt as input into the sort command.

==== Pipe ====
When you need the output from command 1 for the input into command 2, then you would use pipe character '|'. Here is the syntax for the pipe character:

 '''command | command'''

Example:

<pre>
dud@shadowplay:~ $ ls | sort
another_file.txt
file1.pdf
file1.txt
file2.pdf
file3.mp3
file-with_other-NAME.TXT
Yet-Another_file.txt
</pre>

The above example is using the output from `ls` as input to the sort command. You will notice the list has been sorted.

As you can see, the command line is an easy and powerful way of completing many tasks. If you want more information on using the command line, then look at the further reading section of this document.

== Further reading ==

* UsingTheTerminal
* BasicCommands has a list of basic commands.
* AdvancedCommandlineHowto has some advanced command line features such as scripting.

----
CategoryCommandLine
