{|
| '''Warning'''
* This is a '''readonly''' and '''text-based''' archive of a deprecated wiki.
* '''Images''' and '''attachments''' have been removed to conserve space.
* '''Links''' may not work and there may be formatting issues.
* A '''compressed''' version with images and the original syntax is in the repo '''Releases'''.
|}

__TOC__

=== Introduction ===

One of the best features of the shell is globbing. Globbing is the
equivalent of regular expressions of files and directories. As
everything else, it's probably best explained with an example:

<pre>
$ ls
code    devel        downloads   Pictures   src
cat.py	database.py  gravity.py  insert.py  oldmaid.py

$ ls *.py
cat.py	database.py  gravity.py  insert.py  oldmaid.py
</pre>

=== The Basics ===

In the shell, the * character means "match everything". This is the
most common globbing character. So, globbing can be defined has a set of character
that are expanded by the shell. Note, that the globbing characters are
expanded before executing a command. For example:

<pre>
$ ls -F
bar/  baz/  foo  -rf  tata  tintin
$ rm *
$ ls
-rf
</pre>

Here, you see that the directory contains two sub-directories, 'foo'
and 'bar'. The directory also contains a file named '-rf'. The '*' in
the second command, 'rm', is expanded to:

<pre>
$ rm bar baz foo -rf tata tintin
</pre>

Now, you probably know about the '-rf' options of 'rm'. They make
'rm' delete all the directories and their contents. So, why the file
'-rf' is still present after the command as been executed? If you look
carefully the '-rf' file was never given to 'rm', because 'rm' treated
'-rf' as an option. Alternatively, if you had given the '--' option,
which make most commands stop processing options, the result would had
been different:

<pre>
$ ls -F
bar/  baz/  foo  -rf  tata  tintin
$ rm -- *
rm: cannot remove `bar': Is a directory
rm: cannot remove `baz': Is a directory
$ ls
bar   baz
</pre>

=== Globbing characters ===

Here is a list of globbing characters available in most shells:

** <code>?</code>: matches any single character, regardless what the character is.
    <pre>
$ ls
bar baz bzr
$ ls b?r
bar bzr</pre>
* <code>[...]</code>: matches any character inside the brackets. The characters can be either be a range of character or the
    character itself. For example, <code>[a-z]</code> would matches all the lowercase letters through 'a' to 'z'.
    <pre>
$ ls
bar foo FOO
$ ls [A-Z]
FOO</pre>
* <code>[!...]</code>: matches all the characters that are not in the backrets. This is analogous to the caret (^) character used in regular expressions.
    <pre>
$ ls
bar foo FOO
$ ls [!A-Z]
bar foo</pre>
* <code> {p1,p2,...} </code>: matches all the patterns described in the brackets. They can be any of above globbing patterns or specific characters.
    <pre>
$ ls
bar bar2 bar3 baz foo1 foo2 foo3
$ ls {bar,foo[0-9]}
bar foo1 foo2 foo3</pre>

=== Conclusion ===

There's many other globbing characters, but they are often specific to
certain shells. I encourage you to read the section in the manual of
your shell about globbing for more information.
