{|
| '''Warning'''
* This is a '''readonly''' and '''text-based''' archive of a deprecated wiki.
* '''Images''' and '''attachments''' have been removed to conserve space.
* '''Links''' may not work and there may be formatting issues.
* A '''compressed''' version with images and the original syntax is in the repo '''Releases'''.
|}

__TOC__

=== Basic iptables howto ===
Iptables is a firewall, installed by default on all official Ubuntu distributions (Ubuntu, Kubuntu, Xubuntu). When you install Ubuntu, iptables is there, but it allows all traffic by default. Ubuntu comes with <nowiki>[[UFW|ufw]]</nowiki> - a program for managing the iptables firewall easily.

There is a wealth of information available about iptables, but much of it is fairly complex, and if you want to do a few basic things, this How To is for you.

=== Basic Commands ===
Typing
<pre>
sudo iptables -L
</pre>
lists your current rules in iptables.  If you have just set up your server, you will have no rules, and you should see
<pre>
Chain INPUT (policy ACCEPT)
target     prot opt source               destination

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
</pre>

=== Basic Iptables Options ===
Here are explanations for some of the iptables options you will see in this tutorial.  Don't worry about understanding everything here now, but remember to come back and look at this list as you encounter new options later on.
* `-A` - Append this rule to a rule chain.  Valid chains for what we're doing are INPUT, FORWARD and OUTPUT, but we mostly deal with INPUT in this tutorial, which affects only incoming traffic.
* `-L` - List the current filter rules.
* `-m conntrack` - Allow filter rules to match based on connection state.  Permits the use of the `--ctstate` option.
* `--ctstate` - Define the list of states for the rule to match on.  Valid states are:
** NEW - The connection has not yet been seen.
** RELATED - The connection is new, but is related to another connection already permitted.
** ESTABLISHED - The connection is already established.
** INVALID - The traffic couldn't be identified for some reason.
* `-m limit` - Require the rule to match only a limited number of times.  Allows the use of the `--limit` option.  Useful for limiting logging rules.
** `--limit` - The maximum matching rate, given as a number followed by "/second", "/minute", "/hour", or "/day" depending on how often you want the rule to match.  If this option is not used and `-m limit` is used, the default is "3/hour".
* `-p` - The connection protocol used.
* `--dport` - The destination port(s) required for this rule.  A single port may be given, or a range may be given as `start:end`, which will match all ports from `start` to `end`, inclusive.
* `-j` - Jump to the specified target.  By default, iptables allows four targets:
** `ACCEPT` - Accept the packet and stop processing rules in this chain.
** `REJECT` - Reject the packet and notify the sender that we did so, and stop processing rules in this chain.
** `DROP` - Silently ignore the packet, and stop processing rules in this chain.
** `LOG` - Log the packet, and continue processing more rules in this chain.  Allows the use of the `--log-prefix` and `--log-level` options.
* `--log-prefix` - When logging, put this text before the log message.  Use double quotes around the text to use.
* `--log-level` - Log using the specified syslog level.  7 is a good choice unless you specifically need something else.
* `-i` - Only match if the packet is coming in on the specified interface.
* `-I` - Inserts a rule.  Takes two options, the chain to insert the rule into, and the rule number it should be.
** `-I INPUT 5` would insert the rule into the INPUT chain and make it the 5^th^ rule in the list.
* `-v` - Display more information in the output.  Useful for if you have rules that look similar without using `-v`.
* `-s` `--source` - address[/mask] source specification
* `-d` `--destination`  - address[/mask] destination specification
* `-o` `--out-interface` - output name[+] network interface name ([+] for wildcard)
=== Allowing Established Sessions ===
We can allow established sessions to receive traffic:
<pre>
sudo iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
</pre>
* The above rule has no spaces either side of the comma in ESTABLISHED,RELATED

If the line above doesn't work, you may be on a castrated VPS whose provider has not made available the extension, in which case an inferior version can be used as last resort:
<pre>
sudo iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
</pre>

=== Allowing Incoming Traffic on Specific Ports ===
You could start by blocking traffic, but you might be working over SSH, where you would need to allow SSH before blocking everything else.

To allow incoming traffic on the default SSH port (22), you could tell iptables to allow all TCP traffic on that port to come in.
<pre>
sudo iptables -A INPUT -p tcp --dport ssh -j ACCEPT
</pre>
Referring back to the list above, you can see that this tells iptables:
* append this rule to the input chain (-A INPUT) so we look at incoming traffic
* check to see if it is TCP (-p tcp). 
* if so, check to see if the input goes to the SSH port (--dport ssh).
* if so, accept the input (-j ACCEPT).

Lets check the rules: (only the first few lines shown, you will see more)
<pre>
sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     all  --  anywhere             anywhere            state RELATED,ESTABLISHED
ACCEPT     tcp  --  anywhere             anywhere            tcp dpt:ssh
</pre>

Now, let's allow all incoming web traffic
<pre>
sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT
</pre>

Checking our rules, we have
<pre>
sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     all  --  anywhere             anywhere            state RELATED,ESTABLISHED
ACCEPT     tcp  --  anywhere             anywhere            tcp dpt:ssh
ACCEPT     tcp  --  anywhere             anywhere            tcp dpt:www
</pre>

We have specifically allowed tcp traffic to the ssh and web ports, but as we have not blocked anything, all traffic can still come in.

=== Blocking Traffic ===
Once a decision is made to accept a packet, no more rules affect it. As our rules allowing ssh and web traffic come first, as long as our rule to block all traffic comes after them, we can still accept the traffic we want. All we need to do is put the rule to block all traffic at the end.

<pre>
sudo iptables -A INPUT -j DROP
sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     all  --  anywhere             anywhere            state RELATED,ESTABLISHED
ACCEPT     tcp  --  anywhere             anywhere            tcp dpt:ssh
ACCEPT     tcp  --  anywhere             anywhere            tcp dpt:www
DROP       all  --  anywhere             anywhere
</pre>

Because we didn't specify an interface or a protocol, any traffic for any port on any interface is blocked, except for web and ssh.

=== Editing iptables ===

The only problem with our setup so far is that even the loopback port is blocked. We could have written the drop rule for just eth0 by specifying -i eth0, but we could also add a rule for the loopback. If we append this rule, it will come too late - after all the traffic has been dropped. We need to insert this rule before that.  Since this is a lot of traffic, we'll insert it as the first rule so it's processed first.

<pre>
sudo iptables -I INPUT 1 -i lo -j ACCEPT
sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere            state RELATED,ESTABLISHED
ACCEPT     tcp  --  anywhere             anywhere            tcp dpt:ssh
ACCEPT     tcp  --  anywhere             anywhere            tcp dpt:www
DROP       all  --  anywhere             anywhere
</pre>

The first and last lines look nearly the same, so we will list iptables in greater detail.
<pre>
sudo iptables -L -v
</pre>

<pre>
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 ACCEPT     all  --  lo     any     anywhere             anywhere
    0     0 ACCEPT     all  --  any    any     anywhere             anywhere            state RELATED,ESTABLISHED
    0     0 ACCEPT     tcp  --  any    any     anywhere             anywhere            tcp dpt:ssh
    0     0 ACCEPT     tcp  --  any    any     anywhere             anywhere            tcp dpt:www
    0     0 DROP       all  --  any    any     anywhere             anywhere
</pre>

You can now see a lot more information.  This rule is actually very important, since many programs use the loopback interface to communicate with each other.  If you don't allow them to talk, you could break those programs!

=== Logging ===
In the above examples none of the traffic will be logged.  If you would like to log dropped packets to syslog, this would be the quickest way:
<pre>
sudo iptables -I INPUT 5 -m limit --limit 5/min -j LOG --log-prefix "iptables denied: " --log-level 7
</pre>
See Tips section for more ideas on logging.

=== Saving iptables ===
If you were to reboot your machine right now, your iptables configuration would disappear. Rather than type this each time you reboot, however, you can save the configuration, and have it start up automatically. To save the configuration, you can use <code>iptables-save</code> and <code>iptables-restore</code>.

=== Configuration on startup ===
WARNING: Iptables and Ubuntu:NetworkManager can conflict. Also if you are concerned enough about security to install a firewall you might not want to trust NetworkManager.  Also note NetworkManager and iptables have opposite aims.  Iptables aims to keep any questionable network traffic out.  NetworkManager aims to keep you connected at all times.  Therefore if you want security all the time, run iptables at boot time.
If you want security some of the time then NetworkManager might be the right choice.

WARNING: If you use Ubuntu:NetworkManager (installed by default on Feisty and later) these steps will leave you unable to use Ubuntu:NetworkManager for the interfaces you modify.  Please follow the steps in the next section instead.

NOTE: It appears on Hardy, Ubuntu:NetworkManager has an issue with properly on saving and restoring the iptable rules when using the method in the next section.  Using this first method appears to work.  If you find otherwise, please update this note.

Save your firewall rules to a file
<pre>
sudo sh -c "iptables-save > /etc/iptables.rules"
</pre>

At this point you have several options.  You can make changes to `/etc/network/interfaces` or add scripts to `/etc/network/if-pre-up.d/` and `/etc/network/if-post-down.d/` to achieve similar ends.  The script solution allows for slightly more flexibility.

==== Solution #1 - /etc/network/interfaces ====
(NB: be careful - entering incorrect configuration directives into the interface file could disable all interfaces, potentially locking you out of a remote machine.)

Modify the `/etc/network/interfaces` configuration file to apply the rules automatically. You will need to know the interface that you are using in order to apply the rules - if you do not know, you are probably using the interface eth0, although you should check with the following command first to see if there are any wireless cards:
<pre>
iwconfig
</pre>
If you get output similar to the following, then you do not have any wireless cards at all and your best bet is probably eth0.

<pre>
lo        no wireless extensions.

eth0      no wireless extensions.
</pre>

When you have found out the interface you are using, edit (using sudo) your `/etc/network/interfaces`:
<pre>
sudo nano /etc/network/interfaces
</pre>

When in the file, search for the interface you found, and at the end of the network related lines for that interface, add the line:
<pre>
pre-up iptables-restore < /etc/iptables.rules
</pre>

You can also prepare a set of down rules, save them into second file `/etc/iptables.downrules` and apply it automatically using the above steps:
<pre>
post-down iptables-restore < /etc/iptables.downrules
</pre>

A fully working example using both from above:

<pre>
auto eth0
iface eth0 inet dhcp
  pre-up iptables-restore < /etc/iptables.rules
  post-down iptables-restore < /etc/iptables.downrules
</pre>

You may also want to keep information from byte and packet counters.

<pre>
sudo sh -c "iptables-save -c > /etc/iptables.rules" 
</pre>

The above command will save the whole rule-set to a file called `/etc/iptables.rules` with byte and packet counters still intact.

==== Solution #2 /etc/network/if-pre-up.d and ../if-post-down.d ====
''NOTE: This solution uses `iptables-save -c` to save the counters.  Just remove the `-c` to only save the rules.''

Alternatively you could add the `iptables-restore` and `iptables-save` to the `if-pre-up.d` and `if-post-down.d` directories in the `/etc/network` directory instead of modifying `/etc/network/interface` directly.

''NOTE: Scripts in `if-pre-up.d` and `if-post-down.d` must not contain dot in their names.''

The script `/etc/network/if-pre-up.d/iptablesload` will contain:

<pre>
iptables-restore < /etc/iptables.rules
exit 0
</pre>

and `/etc/network/if-post-down.d/iptablessave` will contain:

<pre>
iptables-save -c > /etc/iptables.rules
if [ -f /etc/iptables.downrules ]; then
   iptables-restore < /etc/iptables.downrules
fi
exit 0
</pre>

Then be sure to give both scripts execute permissions:
<pre>
sudo chmod +x /etc/network/if-post-down.d/iptablessave
sudo chmod +x /etc/network/if-pre-up.d/iptablesload
</pre>

==== Solution #3 iptables-persistent ====

Install and use the iptables-persistent package.

=== Configuration on Startup for NetworkManager ===
Ubuntu:NetworkManager includes the ability to run scripts when it activates or deactivates an interface.  To save iptables rules on shutdown, and to restore them on startup, we are going to create such a script.  To begin, press Alt+F2 and enter this command:

For Ubuntu:
<pre>
gksudo gedit /etc/NetworkManager/dispatcher.d/01firewall
</pre>
For Kubuntu:
<pre>
kdesu kate /etc/NetworkManager/dispatcher.d/01firewall
</pre>
Then, paste this script into your editor, save, and exit the editor.
<pre>

if [ -x /usr/bin/logger ]; then
        LOGGER="/usr/bin/logger -s -p daemon.info -t FirewallHandler"
else
        LOGGER=echo
fi

case "$2" in
        up)
                if [ ! -r /etc/iptables.rules ]; then
                        ${LOGGER} "No iptables rules exist to restore."
                        return
                fi
                if [ ! -x /sbin/iptables-restore ]; then
                        ${LOGGER} "No program exists to restore iptables rules."
                        return
                fi
                ${LOGGER} "Restoring iptables rules"
                /sbin/iptables-restore -c < /etc/iptables.rules
                ;;
        down)
                if [ ! -x /sbin/iptables-save ]; then
                        ${LOGGER} "No program exists to save iptables rules."
                        return
                fi
                ${LOGGER} "Saving iptables rules."
                /sbin/iptables-save -c > /etc/iptables.rules
                ;;
***** )
                ;;
esac
</pre>
Finally, we need to make sure Ubuntu:NetworkManager can execute this script.  In a terminal window, enter this command:
<pre>
sudo chmod +x /etc/NetworkManager/dispatcher.d/01firewall
</pre>

=== Tips ===
==== If you manually edit iptables on a regular basis ====
The above steps go over how to setup your firewall rules and presume they will be relatively static (and for most people they should be).  But if you do a lot of development work, you may want to have your iptables saved everytime you reboot.  You could add a line like this one in <code>/etc/network/interfaces</code>:
<pre>
  pre-up iptables-restore < /etc/iptables.rules
  post-down iptables-save > /etc/iptables.rules
</pre>
The line "post-down iptables-save > /etc/iptables.rules" will save the rules to be used on the next boot.

==== Using iptables-save/restore to test rules ====
If you edit your iptables beyond this tutorial, you may want to use the <code>iptables-save</code> and <code>iptables-restore</code> feature to edit and test your rules.  To do this open the rules file in your favorite text editor (in this example gedit).
<pre>
sudo sh -c "iptables-save > /etc/iptables.rules"
gksudo gedit /etc/iptables.rules
</pre>
You will have a file that appears similiar to (following the example above):
<pre>
* filter
:INPUT ACCEPT [368:102354]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [92952:20764374]
-A INPUT -i lo -j ACCEPT
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i eth0 -p tcp -m tcp --dport 22 -j ACCEPT
-A INPUT -i eth0 -p tcp -m tcp --dport 80 -j ACCEPT
-A INPUT -m limit --limit 5/min -j LOG --log-prefix "iptables denied: " --log-level 7
-A INPUT -j DROP
COMMIT
</pre>
Notice that these are iptables commands minus the <code>iptable</code> command.  Feel free to edit this to file and save when complete.  Then to test simply:
<pre>
sudo iptables-restore < /etc/iptables.rules
</pre>
NOTE: With iptables 1.4.1.1-1 and above, a script allow you to test your new rules without risking to brick your remote server. If you are applying the rules on a remote server, you should consider testing it with:
<pre>
sudo iptables-apply /etc/iptables.rules
</pre>
After testing, if you have not added the <code>iptables-save</code> command above to your <code>/etc/network/interfaces</code> remember not to lose your changes:
<pre>
sudo sh -c "iptables-save > /etc/iptables.rules"
</pre>

==== More detailed Logging ====
For further detail in your syslog you may want create an additional Chain.  This will be a very brief example of my /etc/iptables.rules showing how I setup my iptables to log to syslog:
<pre>
* filter
:INPUT ACCEPT [273:55355]
:FORWARD ACCEPT [0:0]
:LOGNDROP - [0:0]
:OUTPUT ACCEPT [92376:20668252]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i eth0 -p tcp -m tcp --dport 22 -j ACCEPT
-A INPUT -i eth0 -p tcp -m tcp --dport 80 -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -j LOGNDROP
-A LOGNDROP -p tcp -m limit --limit 5/min -j LOG --log-prefix "Denied TCP: " --log-level 7
-A LOGNDROP -p udp -m limit --limit 5/min -j LOG --log-prefix "Denied UDP: " --log-level 7
-A LOGNDROP -p icmp -m limit --limit 5/min -j LOG --log-prefix "Denied ICMP: " --log-level 7
-A LOGNDROP -j DROP
COMMIT
</pre>
Note a new CHAIN called <code>LOGNDROP</code> at the top of the file.  Also, the standard <code>DROP</code> at the bottom of the INPUT chain is replaced with <code>LOGNDROP</code> and add protocol descriptions so it makes sense looking at the log.  Lastly we drop the traffic at the end of the <code>LOGNDROP</code> chain.  The following gives some idea of what is happening:
* <code>--limit</code> sets the number of times to log the same rule to syslog
* <code>--log-prefix "Denied..."</code> adds a prefix to make finding in the syslog easier
* <code>--log-level 7</code> sets the syslog level to informational (see man syslog for more detail, but you can probably leave this)

==== Disabling the firewall ====

If you need to disable the firewall temporarily, you can flush all the rules using

<pre>
sudo iptables -P INPUT ACCEPT
sudo iptables -P OUTPUT ACCEPT
sudo iptables -P FORWARD ACCEPT
sudo iptables -F
</pre>
or create a script using text editor such as nano
<pre>
sudo nano -w /root/fw.stop
</pre>

<pre>
echo "Stopping firewall and allowing everyone..."
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -P OUTPUT ACCEPT
</pre>
Make sure you can execute the script
<pre>
sudo chmod +x /root/fw.stop
</pre>
You can run the script
<pre>
sudo /root/fw.stop
</pre>

=== Easy configuration via GUI ===

==== UFW & GUFW ====

<nowiki>[[Gufw|GUFW]]</nowiki> - Gufw is a graphical frontend to <nowiki>[[UFW]]</nowiki> (Uncomplicated Firewall).

=== Further Information ===
<nowiki>[[http://www.frozentux.net/iptables-tutorial/iptables-tutorial.html|Iptables Tutorial]]</nowiki>

<nowiki>[[http://www.netfilter.org/documentation/HOWTO/packet-filtering-HOWTO.html|Iptables How To]]</nowiki>

<nowiki>[[http://www.netfilter.org/documentation/|Netfilter and Iptables Multilingual Documentation]]</nowiki>

<nowiki>[[http://easyfwgen.morizot.net/gen/|Easy Firewall Generator for IPTables]]</nowiki>

<nowiki>[[http://shorewall.net/|Shoreline Firewall]]</nowiki>, a.k.a. Shorewall, is a firewall generator for iptables which allows advanced configuration with simple configuration files.  It is available from the Ubuntu repositories via apt-get.

=== Credits ===
Thanks to Rusty Russell and his How-To, as much of this is based off that.
----
CategorySecurity
