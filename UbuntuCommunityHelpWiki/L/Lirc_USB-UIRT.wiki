{|
| '''Warning'''
* This is a '''readonly''' and '''text-based''' archive of a deprecated wiki.
* '''Images''' and '''attachments''' have been removed to conserve space.
* '''Links''' may not work and there may be formatting issues.
* A '''compressed''' version with images and the original syntax is in the repo '''Releases'''.
|}

__TOC__


== Lirc and the USB-UIRT ==

The USB-UIRT is a usb serial InfraRed device. Support for it is built-in to the kernel via the ftdi_sio driver and usb-serial. In order to make use of it, however, you need to install lirc. To do so, you will need to have '''universe''',  and '''multiverse''' enabled.  See Ubuntu documentation for more information on <nowiki>[[https://help.ubuntu.com/community/Repositories/CommandLine#head-e1a24b1b2037f68b5a95f54388582b58ea4c9bd0|enabling these repositories]]</nowiki>.

==== Install Lirc ====
<pre>
$ sudo apt-get install lirc
</pre>

== Verify the USB-UIRT is detected ==

Plug the usb-uirt device into an available usb port. Check dmesg to make sure it was detected and that the tty was created.:
<pre>
$ dmesg | grep -i usb
</pre>
You should see some output that looks like the following.:
<pre>
[    8.376358] usb 1-2: new full speed USB device using uhci_hcd and address 3
[    8.558634] usb 1-2: configuration #1 chosen from 1 choice
[   14.943365] usbcore: registered new interface driver usbserial
[   14.943374] drivers/usb/serial/usb-serial.c: USB Serial support registered fo
r generic
[   15.043231] usbcore: registered new interface driver usbserial_generic
[   15.043234] drivers/usb/serial/usb-serial.c: USB Serial Driver core
[   15.045761] drivers/usb/serial/usb-serial.c: USB Serial support registered fo
r FTDI USB Serial Device
[   15.045790] ftdi_sio 1-2:1.0: FTDI USB Serial Device converter detected
[   15.045793] drivers/usb/serial/ftdi_sio.c: Detected FT232BM
[   15.045911] usb 1-2: FTDI USB Serial Device converter now attached to ttyUSB0
[   15.045916] usbcore: registered new interface driver ftdi_sio
[   15.045918] drivers/usb/serial/ftdi_sio.c: v1.4.3:USB FTDI Serial Converters Driver}}}
Note the tty that was created. You will use this in the next section. In the above example, it is <code>ttyUSB0</code>, which appears at <code>/dev/ttyUSB0</code>.

== Configure Lirc hardware.conf ==

We need to edit the /etc/lirc/hardware.conf file, specifically, the LIRCD_ARGS, LOAD_MODULES and DRIVER variables. Set the LIRCD_ARGS to tell lircd where to find the serial device to use (you should know from the dmesg command in the previous step), set LOAD_MODULES to false and set the DRIVER to uirt2_raw. Like so:
<pre>
LIRCD_ARGS="-d /dev/ttyUSB0"

LOAD_MODULES=false

DRIVER="uirt2_raw"
DEVICE=""
MODULES=""

LIRCD_CONF=""
LIRCMD_CONF=""
</pre>

== Start lircd ==

Now all you need to do is start lircd and configure remotes in the <code>/etc/lirc/lircd.conf</code> and <code>/etc/lirc/lircrc</code> files. 
<pre>
$ sudo /etc/init.d/lirc start
</pre>
Don't forget to make sure lirc starts at boot, too.

This configuration allows you to both receive and transmit codes. Refer to the other LIRC documentation for instructions on how to test receiving with <code>irw</code> and transmitting with <code>irsend</code>. 

== Newer USB-UIRT Models ==
It has not been confirmed but some newer USB-UIRT Models may need the usb_uirt_raw driver instead of the uirt2_raw driver

<pre>
LIRCD_ARGS="-d /dev/ttyUSB0"

LOAD_MODULES=false

DRIVER="usb_uirt_raw"
DEVICE=""
MODULES=""

LIRCD_CONF=""
LIRCMD_CONF=""
</pre>
----

== Specific to Mythbuntu 11.04 ==

I had some troubles with this, as it did not work directly from the Mythbuntu Control Centre GUI setup. I had to modify some scripts to make it work, so I wanted to post my findings here such that it might help others. 

When I installed the usbuirt, it would register and the drivers would give me access to /dev/ttyUSB0. I could even cat /dev/ttyUSB0 and see stuff happen when I hit a button on my remote. However the Mythbuntu Control Contre config scripts would not allow for the transmitter to work at all, and irw did not work reliably either. At this point I can reliably receive, and transmit worked, but may still have some bugs. I get some check sum error notes in my syslog, but I understand that's unimportant. Here's the basic steps I took to get where I am, then my config files. My setup is mythbuntu 11.04 64bit with a new usbuirt0038z. I have a HVR-1950, which receives video, but is not connected at the moment, as I want to get IR solid before adding other potential USB variables.

USBUIRT device physically plugged in to USB at boot. Check it installed with lsusb and/or lsmod. You should see something that indicates USB serial drivers are installed. Here's what mine looks like.

<pre>
$ lsmod | grep usb
usbserial              42908  3 ftdi_sio
</pre> 

See if you have /dev/ttyUSB0 or similar. Mine is USB0 so I next take a look to verify that data is making to the PC with this command, and pressing a button on the remote. (CTLR C to break when done.)

<pre>
$ cat /dev/ttyUSB0 
lB$ %��$ $��$ $�
</pre>

Great, the PC knows this data is coming in, now we want mode2/irw/LIRC to work, it should produce something like this, however originality it did not. I would see the LED blink on the USBUIRT, but nothing in the IRW output.

With "sudo /etc/init.d/lirc stop" or "ps -A | grep ir" ensure that lirc isn't running. Once you know it's not running you can verify that data can make it to lirc by pressing a button on the remote, mode2 should generate the below 

<pre>
$ mode2 --driver=uirt2_raw --device=/dev/ttyUSB0
space 70500
pulse 950
space 750
pulse 1800
space 1650
pulse 950
space 750
pulse 950
</pre>

Mine also generates some check sum error messages. I understand those are unimportant, as it tries version 1, which fails and generates the error message. Then it tries version 2, which does work.

If that wen't well, great. You can try firing off lirc like this. "sudo /etc/init.d/lirc start" Then you can try irw like this.

<pre>
$ irw 
0000000000001780 00 0 Hauppauge
0000000000001780 01 0 Hauppauge
0000000000001780 02 0 Hauppauge
0000000000001780 03 0 Hauppauge
^C
$ 
</pre>

You should see the LED blink and the above test scroll down the screen when you hit a button. If not then most likely your config scripts are broken. Info is getting to lirc, but the driver might be wrong, or the lircd.conf file might be wrong for your remote.

In my case I'm good to move onto the next step, transmitting. However I expect most that find this will first need to jump to the bottom and figure out the config scripts. For those folks, I recommend working from the bottom up, as you will likely want the echo script modifications first, then you can do your own diagnostics as you modify the other scripts. 

Now that the above is receiving, I have a Dish 322 and I'm only DVRing the optical control channel. So I'll get it to do some basic tasks.

<pre>
$ irsend SEND_ONCE dish info
$ 
</pre>

I saw the LED blink once briefly so it appears I'm good hardware wise. Also I saw the info overlay show up on the screen, so the dish appears to have received the signal.

Now I have to stress test this and see if I need dish, dish1, or one of the other dishes noted in the transmitter directory.

I got the above working with the below config files. 

<pre>
REMOTE="Hauppauge TV card"
REMOTE_MODULES=""
REMOTE_DRIVER="uirt2_raw"
REMOTE_DEVICE="/dev/ttyUSB0"
REMOTE_SOCKET=""
REMOTE_LIRCD_CONF="hauppauge/lircd.conf.hauppauge"
REMOTE_LIRCD_ARGS="-l"

TRANSMITTER="USB-UIRT2 : Dish Receiver"
TRANSMITTER_MODULES=""
TRANSMITTER_DRIVER="uirt2_raw"
TRANSMITTER_DEVICE="/dev/ttyUSB0"
TRANSMITTER_SOCKET=""
TRANSMITTER_LIRCD_CONF="dish/general.conf"
TRANSMITTER_LIRCD_ARGS=""

START_LIRCD="true"

LOAD_MODULES="false"

LIRCMD_CONF=""

FORCE_NONINTERACTIVE_RECONFIGURATION="false"
START_LIRCMD=""
</pre>

I found two remotes named hauppauge, so I changed /etc/lirc/lircd.conf to be like this.

<pre>
include "/usr/share/lirc/remotes/hauppauge/lircd.conf.hauppauge.mod"

include "/usr/share/lirc/extras/transmitters/dish/general.conf"
</pre>

Then I copied lircd.conf.hauppauge to this one, with .mod, and left in this one remote control. I found mine has the "toggle_bit_mask 0x800" by using this command "sudo irrecord -H usb_uirt_raw -d /dev/ttyUSB0 blah_usb_uirt_raw.conf"

<pre>

begin remote

  name  Hauppauge
  bits           13
  flags RC5|CONST_LENGTH
  eps            30
  aeps          100

  one           919   852
  zero          919   852
  plead         930
  gap          112908
  toggle_bit_mask 0x800

      begin codes
          power                    0x17BD
          go                       0x17BB
          tv                       0x179C
          videos                   0x1798
          music                    0x1799
          pictures                 0x179A
          guide                    0x179B
          radio                    0x178C
          exit                     0x179F
          menu                     0x178D
          prevch                   0x1792
          mute                     0x178F
          up                       0x1794
          down                     0x1795
          left                     0x1796
          right                    0x1797
          ok                       0x17A5
          volup                    0x1790
          voldown                  0x1791
          chup                     0x17A0
          chdown                   0x17A1
          record                   0x17B7
          stop                     0x17B6
          rewind                   0x17B2
          fastfwd                  0x17B4
          play                     0x17B5
          replay                   0x17A4
          skip                     0x179E
          pause                    0x17B0
          1                        0x1781
          2                        0x1782
          3                        0x1783
          4                        0x1784
          5                        0x1785
          6                        0x1786
          7                        0x1787
          8                        0x1788
          9                        0x1789
****** 0x178A
          0                        0x1780
###### 0x178E
          red                      0x178B
          green                    0x17AE
          yellow                   0x17B8
          blue                     0x17A9
          sub/cc                   0x178E
          text                     0x178A
          home                     0x17BB
      end codes

end remote
</pre>

I also modified /usr/share/lirc/extras/transmitters/dish/general.conf for 0 repeats. With the default 6 repeats, it would fail and generate messages. It also failed with 1 repeat. 

I used my cell phone camera to verify my original remote was sending a signal, I then compared it to the uirt. I see the uirt has a much shorter pulse, than the original remote. The original remote will pulse as long as you hit the button. I found reliable transmission when I sent via this command

<pre>
irsend SEND_ONCE dish up up
</pre>

Basically the second up command will simulate a longer press on the button. I'll see if I can increase the pulse length in the config file, however for now, it work reliably.

Also here's a command that should show you what lirc has for drivers. You should see uirt2_raw. 

<pre>
irsend LIST "" ""
</pre>

Also the hardware.conf tags don't match the terminology in the LIRC docs, so I added a couple echo lines to my /etc/init.d/lirc script.

<pre>
                        if [ ! -z "$REMOTE_LIRCD_ARGS" ]; then
                                start-stop-daemon --start --quiet --oknodo --exec /usr/sbin/lircd -- $REMOTE_LIRCD_ARGS #< /dev/null
                                echo "R3" start-stop-daemon --start --quiet --oknodo --exec /usr/sbin/lircd -- $REMOTE_LIRCD_ARGS #< /dev/null
                                log_end_msg $?
                                if [ -S "$REMOTE_SOCKET" -a "$OLD_SOCKET" != "$REMOTE_SOCKET" ]; then
                                        rm -f $OLD_SOCKET && ln -s $REMOTE_SOCKET $OLD_SOCKET
                                fi 

################# now if we additionally have a transmitter defined, it is secondary process
                                if [ ! -z "$TRANSMITTER_LIRCD_ARGS" ]; then
                                        /usr/sbin/lircd $TRANSMITTER_LIRCD_ARGS < /dev/null
                                        echo "R4" /usr/sbin/lircd $TRANSMITTER_LIRCD_ARGS #< /dev/null
                                        if [ -S "$TRANSMITTER_SOCKET" ]; then
                                                rm -f ${OLD_SOCKET}1 && ln -s $TRANSMITTER_SOCKET ${OLD_SOCKET}1
                                        fi 
                                fi
</pre>
----
CategoryHardware
